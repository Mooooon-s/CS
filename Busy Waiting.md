## Busy Waiting
원하는 자원을 얻기위해서 기다리는 것이 아니라 권한을 얻을 때까지 반복적으로 확인하는 것

쓰레드가 본인이 필요한 자원을 끊임없이 확인하는 방법

주로 동기화와 관련된 문제를 해결하는 데 사용됨

>하나의 프로세스가 다른 프로세스가 특정 작업을 완료하기를 기다릴 때 그프로세스가 계속해서 상태를 체크하면서 CPU를 사용하게 된는 상황

프로세스가 일정한 조건을 만족할 때까지 계속해서 반복적인 작업을 수행 CPU자원을 소비하는 기법

Os가 원하는 권한을 얻기위해 대기하는 것

장단점
---
장점
1. 간단한 구현
2. 오버헤드 감소 : 컨텍스트 ***스위칭의 오버헤드***가 발생하지 않아 매우 빠르게 반응해야하는 상황에서 유용

단점
1. CPU 자원 낭비 : 프로세스가 아무 일도 하지 않고 CPU시간을 소비하기 때문에 자원 낭비
2. 비효울적 사용 : 다른 프로세스가 CPU를 사용할 수 있는 기회를 빼앗게 됩니다.

예시
---
1. 스핀락(Spinlock)
    - 멀티스레딩 환경에서 스레드 간의 동기화를 위해 사용
    - 스레드가 잠금을 걸기 위해 대기하는 동안 반복적으로 잠금 상태를 체크

2. I/O 폴링 (I/O Polling)
    - 디바이스나 네크워크 상태를 주기적으로 확인하는 과정
    - 데이터가 수신되었는지 반복적으로 상태를 체크

### 대안
--- 
Sleeping으로 해결을 해야함

1. Sleeping
    - 권한을 얻기 위해 기다리는 시간을 Wait Queue에 실행 중인 Thread 정보를 담고 다른 Thread에게 CPU를 양보하는 것
    - 커널은 권한 이벤트가 바생하면 Wait Queue에 담신 Thread정보를 깨워 CPU를 부여한다.

쓰레드의 동기화를 위해서 Bust Waiting 메소드를 사용할 것이 아니라 ***세마포어 또는 Monitor***를 사용해야 한다

> 세마포어가 sleeping을 기반으로 만들어져 있음
> 다른 쓰레드들은 sleeping을 하면서 기다림 세마포어에서 사용가능한 자리가 나면 깨워서 사용하게 만듬

> 뮤텍스 세마포어는 CPU가 쓸데없이 무한 루프를 도는게 아닌 어떤 쓰레드가 공유자원을 획득한 경우 다른 쓰레드는 그 쓰레드가 공유자원을 모두 사용할 때까지 기다린다.


2. 조건 변수
    - 특정 조건이 충족 될때 까지 프로세스를 블록 상태로 유지, 조건이 충족되면 깨원주는 방식

3. 세마포어
    - 프로세스 간의 동기화를 위해 사용, 블록킹 메너니즘을 사용

4. 컨디션 베리어블

## 그럼 언제 사용하기에 이게 있는 거임?
- 자원의 권한을 얻는데 많은 시간이 소요되지 않는 상황인 경우
- Context Switching 비용보다 성능적으로 더 우수한 상황인 경우에 사용하는 것이 효율적