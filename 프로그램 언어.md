# C#
마이크로소프트사에서 닷넷(.NET) 프레임워크를 기반으로 개발한 프로그래밍 언어

C++기반으로 비주얼베이직의 편의성을 결합하여 만든 객체지향 프로그래밍 언어

사용자 친화성, 객체 지향성, 다중성의 특징을 가지고있음

## Generic ( Generic class )
코드의 재사용성과 유연성을 향상해주는 도구

타입을 특정하지 않는 어떤 클래스를 말함

- 데이터 형식을 일반화하여 재사용가능한 코드를 작성할 수 있게 도와줌
    - 여러 데이터 형식에 대해 동일한 로직을 적용할 때
    - 다양한 데이터 형식을 저장하고 관리
    - 데이터 형식에 따라 다른 연상을 수행할 때
    - 간단하게 말해서 여러 타입의 형식에대한 처리를 동일하게 해야할 때

#### 제약 where
타입 파라미터가 값,참조,클래스,인터베이스를 구현한 타입인지를 지정할 수 있음

- 제약을 걸어 사용자가 원하지 않는 형식을 매개변수를 받지 않을 수 있음

## Coroutine
    실행의 지연과 재개를 허용함으로써 비선점적 멀티 태스킹을 위한 서부르틴을 일반화한 컴퓨터프로그램 구성요소

매우 어렵게 설명되어있지만 간단하게 말하면 협력성 멀티 태스킹

비선점적 멀티 태스킹: 쓰레드와 다르게 할당 받으면 종료되기 전까지 다른 프로세스가 강제로 cpu를 차지하지 못함

   - 병행성은 제공하지만 병렬성은 제공하지 않음

코루틴은 집입 후 반환문이 없더라도 임의의 지점에서 실행 중 동작을 중단하고 이후에 해당 지점에서부터 실행을 재개할 수 있음

싱글 쓰레드에서 돌아가는 하나의 함수 같은 것

어째든 절차적으로 접근을 하기 때문에 무조건적 동기화 기법이 적용되지 않음 필요하면 사용 가능

### 특징
1. 중단과 재개: 코루틴은 실행을 중단,재개,종료할 수 있음 
    - yield : 코루틴을 일시 정지
    - await : 중단 및 재개
    - return : 종료
2. 협력형 멀티태스킹: 실행 시간을 공유함
    - 하나의 코루틴이 실행을 중단하면 다른 코루틴이 실행을 계속할 수 있음
3. 상태 보존: 중단 시점의 상태를 보존하여 다음 재개 시점부터 이전 상태를 그대로 이어서 실행

### 그 외
쓰레드와는 다른 개념

가독성이 올라감에 따라 유지보수성 상승

성능 증가

즉 컨텍스트 스위칭이 일어나지 않음 하나의 스레드에서 함수가 정지 되었다가 재개 되는 것임


# C++
C언어 기반으로 만들어졌으며 C언어를 개선함과 동시에 객체지향 프로그래밍 기능을 추가

## 생성자,소멸자 호출
생성자와 소멸자는 c++에서 클래스를 사용할 때 중요한 개념

### 생성자
클래스의 인스턴스가 생성될 때 자동으로 호출되는 특별한 함수

클래스와 객체지향 프로그래밍의 핵심 구성요소

클래스를 정의할 때 생성자를 이용해서 어떻게 초기화 할지 결정할 수 있음
- 생성자는 보통 클래스와 돌일한 이름을 가짐 
- 리턴타입을 명시하지않음
    - 생성자는 인스턴스를 생성하기 떄문

- 기본 생성자, 매개변수 생성자 , 복사 생성자같이 여러 형태가 존재
### 소멸자
클래스의 객체가 메모리에서 제거될 때 자동으로 호출되는 특별한 함수
- 클래스와 객체의 생명주기를 관리하는 큰 역할

소멸자는 생성자와같이 클래스와 동일한 이름을 가지지만 앞에 '~'가 붙음

한 클래스에서 단 하나만 존재함

### 생성자와 소멸자의 역할
- 생성자
    - 객체 초기화
        - 인스턴스가 생성될 때 멤버 변수가 생성자에의해서 초기화됨
    - 리소스 할당
        - 객체가 필요로하는 리소스나 일련의 사전 작업이 이루어짐
- 소멸자
    - 리소스 해제
        - 할당 받은 리소스 들을 해제해서 메모리 누수문제를 방지
    - 마무리 작업
        - 객체가 더 이상 필요하지 않을 때, 마무리 작업

### 객체 생성과 소멸 순서
무조건 생성자가 먼저 호출되고 소멸자가 호출됨

객체안에 다른 객체가 존재 한다면?

A객체 안에 B객체가 존재한다면

A객체의 인스턴스가 생성되고 인스턴스가 소멸할 때

A의 생성자 -> B 생성자 -> A 소멸자 -> B 소멸자

## 디폴트 생성자
    Point::Point() { }

컴파일러가 자동으로 생성하는 일반 생성자

## 복사 생성자
    Point::Point(const Point& obj)
    {
	    x = obj.x;
        y = obj.y;
    }

객체를 복사하기 위해 사용되는 특수한 형태의 생성자

한 객체의 내용을 다른 객체로 복사하여 생성된 생성자

생성자를 호출하는 객체와 동일한 타입의 객체를 인자로 받아 동일하게 객체를 구성하는 생성자

- 자신과 같은 타입의 객체를 인자로 받음
- 복사 생성자가 정의 되어있지 않으면 디폴트 복사 생성자가 생성됨

### 호출되는 시기
1. 객체가 다른 객체로 초기화될 때
2. 객체가 함수의 매개변수로 전달될 때
3. 객체가 함수의 반환값으로 반환될 때

## 얕은 복사 , 깊은 복사
### 얕은 복사
- 객체의 멤버 변수만 복사
- 멤버 변수가 포인터인 경우 포인터 주소만 복사
- 두 객체가 동일한 메모리 주소를 참조

### 깊은 복사
- 클래스 자체를 복사
- 객체의 멤버변수가 포인터의 경우 포인터가 가리키는 실제 데이터도 복사
- 두 객체가 각각 독립적인 메모리 공간을 가짐

## 오버라이딩, 오버로딩
    다형성을 챙기기 위한 방법
### 오버라이딩
상위 클래스의 메소드를 하위 클래스에서 재정의 하는것
- 반환값이나 매개변수 모두 똑같이 하고 정의 해야함

### 오버로딩
메소드 이름은 같지만 매개변수의 타입이나 갯수를 다르게해서 중복으로 정의하는 것
- 반환값만 다르게 해서 정의할 수 없음

## 함수 재정의 & 함수 오버라이딩
### 함수 재정의
부모 클래스에서 정의된 함수를 자식 클래스에서 동일한 형식의 함수를 정의하는 것
- 동일한 형식 : 리턴값, 매개변수의 타입 및 갯수 ,메소드 이름을 모두 같은 것
- 재정의한 함수를 부모 클래스의 포인터로 접근하면 부모 클래스의 함수가 호출됨, 자식 클래스 포인터로 접근하면 자식클래스의 함수가 호출
- 호출시 해당 포인터의 클래스에 함수로 호출되기 때문에 컴파일 시점에서 결정됨 -> 정적 바인딩

### virtual 함수 ( 가상 함수 )
virtual 키워드로 선언된 함수
- virtual : 컴파일러에게 자신에 대한 호출 바인딩을 런타임까지 미루도록 지시하는 키워드

- 순수 가상함수 
    - 상속받은 자식 클래스에서 반드시 오버라이딩을 해야함
    - 인스턴스는 생성 할 수 없음

### virtual 소멸자
부모 클래스에 virtual 소멸자가 존재한다면 자식껏도 같이 호출이 되지만 없다면 부모만 호출이 됨

### 함수 오버라이딩
기본 클래스 즉 부모 클래스 앞에 virtual이라는 키워드를 붙이고 동일한 형식의 함수를 정의하는 것
- virtual을 붙여서 동적 바인딩을 한다는 뜻임
- 기본 클래스의 포이터든 파생 클래스의 포인터든 어떤걸 이용하든 가상함수를 호출하면 파생클래스의 함수가 호출됨

### RTTI
    Run time type Information 의 약자로 프로그램 실행중에 실시간으로 데이터의 타입을 얻어올 때 사용하는 방법

#### typeid( param p )
 RTTI는 typeid 연산자에 데이터나 타입을 담아서 정보를 얻어올 수 있고 type_info로 반환 된다.

 - name()을 통해 해당 타입의 이름을 받아올 수 있음

- dynamic_cast , virtual에서 사용되고 있음

## C++ Template
프로그래머가 개별적으로 작성하지 않아도 원하는 타입을 넣어주면 알아서 코드를 찍어내는 틀과 같은 것

컴파일 시점에 타입 독립적인 코드를 생성하는 기능

함수와 클래스를 다양한 타입으로 쉽개 재사용이 가능함

## C++ Template VS C# Generic class
- C++ 템플릿은 1번의 컴파일 C# 제네릭은 두번의 컴파일 과정을 거침
    - C++ 템플릿은 사용하지 않으면 컴파일 되지 않음 -> 커파일 시점에 타입을 결정
    - C# 제네릭은 사용하지 않아도 메타데이터가 생성됨 -> 런타임 시점에 타입을 결정

- 제네릭에서는 비타입 템플릿 매개변수를 허용하지 않음
    - template c<int i> {} 이런거
    - 비타입 매개변수
        - 정수, 포인터 , 참조 등
    - 타입 매개변수
        - typename T 같은거
        
- 지정한 타입인 경우에만 다르게 동작하도록하는 Template Specialization은 제네릭에서는 불가능
    - T로 선언 했지만 int형으로 미리 선언되어있다면 int형으로 선언되어있는걸 사용하는 것

### Template Meta Programing ( TMP )
일반화 프로그래밍 ( generic programming )이라고도 함

템플릿 인자로 타입뿐만 아니라 특정한 조건을 만족하는 값이 올 수 있음

객체를 생성하지 않더라도 타입에 어떠한 값을 부여할 수 있고 또 그 타입들을 가지고 연산을 할 수 있다

컴파일 타임에 확정되야하므로 모든 연산은 컴파일 타임에 끝남

타입을 가지고 컴파일 타임에 생성되는 코드로 프로그래밍을 하는 것을 *** 메타 프로그래밍 ***이라고 함

C++에서는 이를 템플릿을 가지고 이러한 작업을 하기 때문에 *** 템플릿 메타 프로그래밍 *** 이라고 함

#### 사용하는 이유?
- 컴파일 단계에서 모든 연산이 끝나기 때문에 프로그램 실행 속도를 향상 시킬 수 있음 ( 컴파일 시간은 느러남 )
- 단점도 존재함
    - 디버깅이 어려움
        - 런타임 때 결정되지 않기 때문에 찾기 힘듬
        - 코드도 복잡해짐

## C++ 메모리 관리
c++는 수동으로 메모리를 관리가 가능
그만큼 메모리 관리를 세세하게 할 수 있지만 잘 못할 경우 메모리 누누나 이중해제등 심각한 문제를 초래할 수 있음

### 스택,힙 메모리
- 스택 메모리: 함수 호출시 자동으로 할당 종료시 자동으로 해제
- 힙 메모리 : 동적 할당 및 해제 메모리로 개발자가 명시적으로 할당하고 해제해야함

### 수동 메모리 관리
메모리를 계속 할당하면 오버헤드가 발생
new 가 그냥 발생함 메모리 쓸거야 , 어디 줘 , 등등 때문에 

메모리 할당할 때 오버헤드를 신경써주어야함

#### new delete
c++에서 기본적으로 동적 할당을 할때 new 연산자를 이용
- 힙 메모리에 할당됨
- 포인터 변수를 선언하면 nullptr이나 포인터 변수로 초기화 하는게 좋음

해제할 때는 delete를 이용 스마트 포인터를 이용하지 않았다면 반드시 delete를 해주어야함

#### new VS malloc
- malloc은 라이브러리 제공함수 라이브러리를 추가해주어야함 new는 기본 함수로 그냥 사용가능
- malloc은 동적할당만을 위한 목적이기 때문에 초기화가 불가능
- new는 생성자를 자동으로 호출
- realloc을 통해 재할당이 가능하지만 new는 복잡한 과정을 따로 해주어야함

#### 메모리 풀
고정되고 연속된 메모리 공간을 미리 할당하고 이 메모리를 가져다가 사용하고 반납하는 방식
지속적으로 사용한다면 매우 효율이 좋음

#### 포인터
다른 변수의 메모리 주소를 가리키는 변수

#### 스마트 포인터
동적으로 할당한 메모리를 관리하기 쉬움

객체의 생명 주기를 자동으로 관리하여 메모리 누수를 방지
- 메모리 누수를 방지하려면 스마트 포인터를 적극활용하는게 좋음

unique_ptr
- 단일 소유권을 가지고 소유권을 명시적으로 이동 가능
    - std::move 를 사용
- 이 포인터가 가리키고 있는 공간을 다른 포인터가 가리킬수 없음

shared_ptr
- 참조 카운팅을 사용 여러 개의 포인터가 같은 자원을 고유 할 수 있음 
- 마지막 Shared_ptr이 소멸되면 메모리가 해제됨
- 래퍼런스 포인터를 하나씩 올렸다가 내림

weak_ptr
- shared_ptr과 함께 사용되며 순환 참조를 방지
- 자원을 획득하지만 소유권을 가지지 않음
- 래퍼런스 포인터를 올리지 않음
- 객체 생존 여부 확인 할 때
- 순환 참조 문제를 방지하는데에

### RAII ( Resource Acquisition Is Initialization )
자원의 획득과 해제를 객체의 생성과 소멸 시점에 맞추는 기법
- 생성자에서 자원을 획득
- 소멸자에서 자원을 해제

### 댕글링 포인터
    포인터가 여전히 해제된 메모리 영역을 가리키고 있는 포인터

메모리를 해제 하고나서도 포인터가 해당위치를 참조하고 있는 상황

- 메모리 접근시 예측 불가능한 동작
 
- 메모리 접근 불가 시 Segmentation fault
 
- 잠재적인 보안 위험

#### 최소화 시키기
- 포인터 해제 이후 null로 초기화

### void * (void 포인터)
    포인터인데 타입이 없는 포인터

    타입이라기 보다는 주소값을 저장하는 포인터

주소값을 저장하지만 주소값만 저장하기 때문에 어떠한 타입이 들어있는지 알 수 없음

때문에 형변환을 통해 해당 주소에 접근을 해야함


## 모던 c++
c++11 이후의 버전들을 말한다.

기존의 C와 호환이 가능함과 동시에 더 간단하고 안정적이고 빠른 코드를 제공한다.

기능들은 버전이 높아지면서 점점 추가가 된다.

### 추가된 기능들 몇 가지

- auto
    - 컴파일러가 선언된 변수 또는 람다 식 변수의 초기화 식을 사용하여 타입을 추론하는 키워드
- using
    - namespcae 와 별칭 선언시 사용할 수 있게 되는 키워드
        - C++11 이전 typedef c++이후 using
        - typedef pair<int,int> pii;
        - using pii = pair<int,int>;

- 범위 기반 for문
    - 컨테이너에 있는 모든원소를 순차적으로 접근하는 반복문
    - 이터레이터로 접근하기에 범위가 begin()과 end()로 정의되는 것이어야함

- 람다 표현식
    - 이름없는 함수 객체를정의하는 방법
    - 함수의 포인터 또는 함수 객체를 대체할수있음
    - ex) auto square = [](double) { reutnr a * a};
    - ex) square(1.5)

    - 구현부나 선언부가 필요 없기 때문에 가독성이 좋아짐
    - 다른 클래스나 이런 곳에서 이 함수를 사용할 수 없기 때문에 이걸 난발하면 좋지 않음
    - 아마 간단한 수학식을 쓸 때

- Closure
    - 람다 표현식에 대한 런타임 결과는 오브젝트의 생성 이러한 오브젝트를 클로져라고 함
    - 람다가 클래스 클로져가 인스턴스 같은 느낌
    - 위의 예제에서 square는 복사본이지 클로져가 아님
        - 클로져는 해당 줄의 마지막에서 파괴됨
    

- chrono 라이브러리
    - OS독립적으로 정밀한 시간을 측정할 수 있게해주는 라이브러리
    - < chrono >에 정의되어있음
    - 나노초까지 측정가능



# C++ 와 C#의 차이점
- 둘다 객체 지향 언어이지만 C#은 모든 것을 객체로 취급하기 때문에 컴포넌트 지향 프로그래밍 언어라고도 함
    - 컴포넌트
        - 재사용이 가능한 각각의 구성 요소 ( 독립된 모듈 )
        - 레고 불록과 같이 이미 만들어진 컴포넌트들을 조합하여 구성가능

    - 객체지향은 ***클래스 간의 연관성*** 에 초점을 맞추지만 컴포넌트 지향은 ***자체적으로 작동하는 교환 가능한 모듈***을 가용한다는 것

- C++는 컴파일시 기계코드로 직접 변환하지만 C#은 중간언어로 번환됨

- C++ 메모리를 수동으로 처리 C#은 갈비지컬렉터가 자동으로 처리

- C#에서는 포인터를 사용할수 없음

# Primitive type VS Reference type

## Primitive type
원시 타입이라고도 하며 정수 실수 문자 논리 리터럴 등의 실제 데이터 값을 저장하는 타입

변수에 값을 저장

- int , float, double 등등

## Reference type
참조 타입이라고도 하며 객체를 참조하는 타입

메모리 번지 값을 통해 객체를 참조하는 타입

메모리 상에 객체가 있는 위치를 저장

- pointer나 클래스가 있음

## 차이점
- null 값 저장 및 제네릭 타입
    - Primitive는 null값을 저장할 수 없다
    - Primitive는 제네릭 타입에서 사용할 수 없음
- 접근 속도
    - Primitive가 더 빠르다
        - stack 메모리에 값이 존재
        - stack에 참조값만 있고 실제로는 heap영역에 존재

# 객체 지향
    프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체로 만듬
    객체들 간의 상호작용을 통해 로직을 구성하는 프로그래밍 방법

## 특징
- 추상화
    - 공통적으로 필요로 하는 속성이나 동작을 본질에 착안해서 하나로 만들어내는 작업
    - 세부사항은 제거하고 가장 본질적이고 공통적인 부분만을 추출
- 캡슐화
    - 데이터와 메서드를 하나의 단위로 묶어 외부에서 접근하지 못하도록 보호하는 개념
    - 데이터 보호 , 은닉
- 상속
    - 기본의 클래스를 재활용하여 새로운 클래스를 작성하는 것
- 다형성
    - 어떤 객체의 속성이나 기능이 상황에 따라 여러 가지 형태를 가질 수 있는 성질

## SOLID원칙

### SRP 단일 책임 원칙
작성된 클래스는 하나의 기능만 가지며 클래스가 제공하는 기능은 하나의 책임을 수행
### OCP 개방폐쇄의 원칙
확장는 쉽게 변경은 어렵게
### LSP 리스코브 치환의 원칙
하위 타입은 상위 타입으로 대체될 수 있어야한다.
### ISP 인터페이스 분리의 원칙
목적과 관심이 각기 다른 클라이언트가 있다면 인터페이스를 통해 적절하게 분리
### DIP 의존성역전의 원칙
고수준 모듈은 저수준 모듈에 의존해선 안되고 저수준 모듈이 고수준 모듈에 의존되어야함

## 장점
- 모듈화,캡슐화로 인해 유지보수가 용이
- 재사용에 용이

## 단점
- 대부분의 객체지향 프로그램은 속도가 상대적으로 느리고 메모리를 많이 사용
- 설계 및 작성하는 데 시간이 다소 걸림

# Call by Value, Call by Reference

## Call by Value
함수 호출 시 넘기는 인자의 값이 매개변수에 복사(Copy)돼서 함수 내에서 매개변수에 직접적인 데이터 조작을 가해도 인자에 전혀 영향을 주지 않는 것
- 원본 값이 들어온것이 아니기 때문에 인자값을 수정해도 원본 값은 그대로임

## Call by Reference
함수 호출 시 넘기는 인자의 값이 매개변수에 복사(Copy)된다는 점은 동일 다만 복사되는 값이 데이터의 주소 값이라는 차이점
- 주소값이 복사 되기에 넘겨진 인자값을 수정하면 원본 값도 수정됨

# goto문
goto문은 cpu가 코드의 다른 지점으로 점프하도록하는 제어 흐름 명령문

점프하는 지점은 문 라벨 ":"을 사용하여 식별
- goto와 동일한 블록에서 초기화된 변수 앞으로 건너 뛸수 없음

## 특징
- 일반적으로 goto는해로운 코드로 간주 때문에 거의 사용되지 않음
    - 실행지점을 뛰어넘게 하기 때문에 스파게티 코드를 만들게 됨

# struct vs class
사용자 데이터 타입을 정의 할 때 사용됨
멤버와 함수를 가질 수 있음

## struct
데이터의 집합체로 사용됨

기본접근 지정자로 public으로 정의

## class
객체지향 프로그래밍에서 객체의 정의를 위해 사용됨

기본접근 지정자로 private로 정의

상속 다형성 및 갭슐화와 같은 객체지향 개념을 더 잘 지원

# class vs interface

## 클래스
객체의 구조와 동작을 정의할 수 있음
- 속성과 메서드를 포함
- 인스턴스를 생성할 수 있음

### 추상클래스
순수 가상함수가 하나 이상있는 경우를 추상 클래스라고 함

인스터스화 할수 없는 클래스

## 인터페이스
클래스가 구현해야 하는 메서드의 목록을 정의
- 구현 자체를 포함하지 않음

선언부가 아예 없는 클래스를 인터페이스라고 함
- 생성자를 제외한 모든 함수가 순수 가상함수로 이루어져있음

인터페이스를 통해 다중 상속을 구현 할 수 있음

# overflow , underflow
    표현할 수 있는 범위에서 최소값 미만인 경우 underflow 최대값 이상인 경우 overflow라고 함

표현 가능한 최대 범위에서 값이 더해질 경우 부호를 결정하는 가장 앞의 비트( 최상위 비트 MBS )가 변화하면서 양수가 음수로 변함 이를 overflow라고 함

# Parallel class
병렬처리를 쉽게 구현할 수 있도록 도와주는 클래스

# Parallel.for
.NET 프레임워크에서 제공하는 메서드로, 반복 작업을 병렬로 실행할 수 있도록 도와 줌

다중 쓰레드로 반복문을 병렬처리하는 거기 때문에 순서의 영향을 받지 않음
- for문을 돌리지만 i를 출력했을 때 i가 1씩 증가하는게 아니라 랜덤하게 i가 찍힐 것임
- Parallel.For(0, 10, i => { ... })
- 복잡한 병렬처리를 효율적으로 처리가 가능

# Const
변수를 상수화 시키는 키워드
- 고정되어 있어야 할 값을 변수에 저장해서 사용하면 변할 가능성이 있기 때문에 이걸 고정 시키는 역할

- 변수 앞의 const
    - 변수의 값을 변경 할 수 없음
    - 타입 앞이든 변수명 앞이든 아무 상관 없음
        - const int t;
        - int const t;

- const 포인터 변수
    - 맨 앞에 위치할 때
        - 타입 앞에 존재하면 그 포인터를 상수화 시킨 것
            - 포인터 자체에 할당이 안됨
            - 이미 할당된 변수는 변경이 가능
            - const int* t;
    
    - 중간에 있을 때
        - 타입 뒤에 존재하는 것으로 포인터가 가리키는 주소를 변경하지 못함
        - 포인터 자체를 상수화 시킨것 다른 주소를 가리키게 할 수 없음
        - int* const t;
    
- 함수에서 포인터 변수 사용
    - 매개 변수 자료형에 사용될 경우
        - 함수 내에서 인자 값을 변경하고 싶지 않을 떄
    - 함수의 맨 뒤에 선언 될 경우
        - 함수 내에서 멤버 변수를 변경하지 못함
    - 함수의 맨 앞 리턴부분에 선언 될 경우
        - 반환 값을 상수화 시켜서 반환
        - 일반적으로는 의미 없지만 래퍼런스로 받을 때 사용

#  Friend class
    클래스에 대한 friend선언은 원본 클래스의 private,public, protected의 접근 권한을 또 다른 클래스에 넘겨주는 것

클래스 선언 시에 권한을 주고 싶은 클래스를 public 에서 선언 해주면됨 " firend class test; "

특정 함수만 프렌드화 해서 권한을 부여 해줄 수 도 있음

# argument, parameter
## argument
    매개변수 , 함수와 메서드 입력 변수명

## parameter
    함수와 메서드의 입력 값

## 가변 인자
    고정되지 않은 인자

    void func(int ...) {} 인자 뒤에 "..."을 붙여서 선언

원하는 타입을 입력한 만큼 받겠다는 의미

## 가변길이 템플릿
    template <typename T, typename... Types> 와 같이 선언이 가능

typename뒤에 있는 "..."으로 *** 템플릿 파라미터 팩 *** 이라고 함

마찬가지로 함수에 인자로 "..."이 있는데 이것은 *** 함수 파라미터 팩 *** 이라고함

- 템플릿 파라미터 팩
    - 0개 이상의 템플릿 인자들
- 템플릿은 타입 앞에 함수는 타입 뒤에 붙음
- 파라미터 팩은 추론된 인자를 제외한 나머지를 나타내게 됨