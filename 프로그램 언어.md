# C#
마이크로소프트사에서 닷넷(.NET) 프레임워크를 기반으로 개발한 프로그래밍 언어

C++기반으로 비주얼베이직의 편의성을 결합하여 만든 객체지향 프로그래밍 언어

사용자 친화성, 객체 지향성, 다중성의 특징을 가지고있음

## Generic ( Generic class )
코드의 재사용성과 유연성을 향상해주는 도구

타입을 특정하지 않는 어떤 클래스를 말함

- 데이터 형식을 일반화하여 재사용가능한 코드를 작성할 수 있게 도와줌
    - 여러 데이터 형식에 대해 동일한 로직을 적용할 때
    - 다양한 데이터 형식을 저장하고 관리
    - 데이터 형식에 따라 다른 연상을 수행할 때
    - 간단하게 말해서 여러 타입의 형식에대한 처리를 동일하게 해야할 때

#### 제약 where
타입 파라미터가 값,참조,클래스,인터베이스를 구현한 타입인지를 지정할 수 있음

- 제약을 걸어 사용자가 원하지 않는 형식을 매개변수를 받지 않을 수 있음

## Coroutine
    실행의 지연과 재개를 허용함으로써 비선점적 멀티 태스킹을 위한 서부르틴을 일반화한 컴퓨터프로그램 구성요소

매우 어렵게 설명되어있지만 간단하게 말하면 협력성 멀티 태스킹

비선점적 멀티 태스킹: 쓰레드와 다르게 할당 받으면 종료되기 전까지 다른 프로세스가 강제로 cpu를 차지하지 못함

   - 병행성은 제공하지만 병렬성은 제공하지 않음

코루틴은 집입 후 반환문이 없더라도 임의의 지점에서 실행 중 동작을 중단하고 이후에 해당 지점에서부터 실행을 재개할 수 있음

싱글 쓰레드에서 돌아가는 하나의 함수 같은 것

어째든 절차적으로 접근을 하기 때문에 무조건적 동기화 기법이 적용되지 않음 필요하면 사용 가능

### 특징
1. 중단과 재개: 코루틴은 실행을 중단,재개,종료할 수 있음 
    - yield : 코루틴을 일시 정지
    - await : 중단 및 재개
    - return : 종료
2. 협력형 멀티태스킹: 실행 시간을 공유함
    - 하나의 코루틴이 실행을 중단하면 다른 코루틴이 실행을 계속할 수 있음
3. 상태 보존: 중단 시점의 상태를 보존하여 다음 재개 시점부터 이전 상태를 그대로 이어서 실행

### 그 외
쓰레드와는 다른 개념

가독성이 올라감에 따라 유지보수성 상승

성능 증가

즉 컨텍스트 스위칭이 일어나지 않음 하나의 스레드에서 함수가 정지 되었다가 재개 되는 것임


# C++
C언어 기반으로 만들어졌으며 C언어를 개선함과 동시에 객체지향 프로그래밍 기능을 추가

## 생성자,소멸자 호출
생성자와 소멸자는 c++에서 클래스를 사용할 때 중요한 개념

### 생성자
클래스의 인스턴스가 생성될 때 자동으로 호출되는 특별한 함수

클래스와 객체지향 프로그래밍의 핵심 구성요소

클래스를 정의할 때 생성자를 이용해서 어떻게 초기화 할지 결정할 수 있음
- 생성자는 보통 클래스와 돌일한 이름을 가짐 
- 리턴타입을 명시하지않음
    - 생성자는 인스턴스를 생성하기 떄문

- 기본 생성자, 매개변수 생성자 , 복사 생성자같이 여러 형태가 존재
### 소멸자
클래스의 객체가 메모리에서 제거될 때 자동으로 호출되는 특별한 함수
- 클래스와 객체의 생명주기를 관리하는 큰 역할

소멸자는 생성자와같이 클래스와 동일한 이름을 가지지만 앞에 '~'가 붙음

한 클래스에서 단 하나만 존재함

### 생성자와 소멸자의 역할
- 생성자
    - 객체 초기화
        - 인스턴스가 생성될 때 멤버 변수가 생성자에의해서 초기화됨
    - 리소스 할당
        - 객체가 필요로하는 리소스나 일련의 사전 작업이 이루어짐
- 소멸자
    - 리소스 해제
        - 할당 받은 리소스 들을 해제해서 메모리 누수문제를 방지
    - 마무리 작업
        - 객체가 더 이상 필요하지 않을 때, 마무리 작업

### 객체 생성과 소멸 순서
무조건 생성자가 먼저 호출되고 소멸자가 호출됨

객체안에 다른 객체가 존재 한다면?

A객체 안에 B객체가 존재한다면

A객체의 인스턴스가 생성되고 인스턴스가 소멸할 때

A의 생성자 -> B 생성자 -> A 소멸자 -> B 소멸자

## 디폴트 생성자
    Point::Point() { }

컴파일러가 자동으로 생성하는 일반 생성자

## 복사 생성자
    Point::Point(const Point& obj)
    {
	    x = obj.x;
        y = obj.y;
    }

객체를 복사하기 위해 사용되는 특수한 형태의 생성자

한 객체의 내용을 다른 객체로 복사하여 생성된 생성자

생성자를 호출하는 객체와 동일한 타입의 객체를 인자로 받아 동일하게 객체를 구성하는 생성자

- 자신과 같은 타입의 객체를 인자로 받음
- 복사 생성자가 정의 되어있지 않으면 디폴트 복사 생성자가 생성됨

### 호출되는 시기
1. 객체가 다른 객체로 초기화될 때
2. 객체가 함수의 매개변수로 전달될 때
3. 객체가 함수의 반환값으로 반환될 때

## 얕은 복사 , 깊은 복사
### 얕은 복사
- 객체의 멤버 변수만 복사
- 멤버 변수가 포인터인 경우 포인터 주소만 복사
- 두 객체가 동일한 메모리 주소를 참조

### 깊은 복사
- 객체의 멤버변수가 포인터의 경우 포인터가 가리키는 실제 데이터도 복사
- 두 객체가 각각 독립적인 메모리 공간을 가짐

## 오버라이딩, 오버로딩
### 오버라이딩
상위 클래스의 메소드를 하위 클래스에서 재정의 하는것
- 반환값이나 매개변수 모두 똑같이 하고 정의 해야함

### 오버로딩
메소드 이름은 같지만 매개변수의 타입이나 갯수를 다르게해서 중복으로 정의하는 것
- 반환값만 다르게 해서 정의할 수 없음

## 함수 재정의 & 함수 오버라이딩
### 함수 재정의
부모 클래스에서 정의된 함수를 자식 클래스에서 동일한 형식의 함수를 정의하는 것
- 동일한 형식 : 리턴값, 매개변수의 타입 및 갯수 ,메소드 이름을 모두 같은 것
- 재정의한 함수를 부모 클래스의 포인터로 접근하면 부모 클래스의 함수가 호출됨, 자식 클래스 포인터로 접근하면 자식클래스의 함수가 호출
- 호출시 해당 포인터의 클래스에 함수로 호출되기 때문에 컴파일 시점에서 결정됨 -> 정적 바인딩

### virtual 함수 ( 가상 함수 )
virtual 키워드로 선언된 함수
- virtual : 컴파일러에게 자신에 대한 호출 바인딩을 런타임까지 미루도록 지시하는 키워드

- 순수 가상함수 
    - 상속받은 자식 클래스에서 반드시 오버라이딩을 해야함
    - 인스턴스는 생성 할 수 없음

### 함수 오버라이딩
기본 클래스 즉 부모 클래스 앞에 virtual이라는 키워드를 붙이고 동일한 형식의 함수를 정의하는 것
- virtual을 붙여서 동적 바인딩을 한다는 뜻임
- 기본 클래스의 포이터든 파생 클래스의 포인터든 어떤걸 이용하든 가상함수를 호출하면 파생클래스의 함수가 호출됨

### RTTI
    Run time type Information 의 약자로 프로그램 실행중에 실시간으로 데이터의 타입을 얻어올 때 사용하는 방법

#### typeid( param p )
 RTTI는 typeid 연산자에 데이터나 타입을 담아서 정보를 얻어올 수 있고 type_info로 반환 된다.

 - name()을 통해 해당 타입의 이름을 받아올 수 있음

- dynamic_cast , virtual에서 사용되고 있음

### Template Meta Programing ( TMP )
일반화 프로그래밍 ( generic programming )이라고도 함

템플릿 인자로 타입뿐만 아니라 특정한 조건을 만족하는 값이 올 수 있음

객체를 생성하지 않더라도 타입에 어떠한 값을 부여할 수 있고 또 그 타입들을 가지고 연산을 할 수 있다

컴파일 타임에 확정되야하므로 모든 연산은 컴파일 타임에 끝남

타입을 가지고 컴파일 타임에 생성되는 코드로 프로그래밍을 하는 것을 *** 메타 프로그래밍 ***이라고 함

C++에서는 이를 템플릿을 가지고 이러한 작업을 하기 때문에 *** 템플릿 메타 프로그래밍 *** 이라고 함

#### 사용하는 이유?
- 컴파일 단계에서 모든 연산이 끝나기 때문에 프로그램 실행 속도를 향상 시킬 수 있음 ( 컴파일 시간은 느러남 )
- 단점도 존재함
    - 디버깅이 어려움
        - 런타임 때 결정되지 않기 때문에 찾기 힘듬
        - 코드도 복잡해짐

## C++ 메모리 관리
c++는 수동으로 메모리를 관리가 가능
그만큼 메모리 관리를 세세하게 할 수 있지만 잘 못할 경우 메모리 누누나 이중해제등 심각한 문제를 초래할 수 있음

### 스택,힙 메모리
- 스택 메모리: 함수 호출시 자동으로 할당 종료시 자동으로 해제
- 힙 메모리 : 동적 할당 및 해제 메모리로 개발자가 명시적으로 할당하고 해제해야함

### 수동 메모리 관리
#### new delete
c++에서 기본적으로 동적 할당을 할때 new 연산자를 이용
- 힙 메모리에 할당됨
- 포인터 변수를 선언하면 nullptr이나 포인터 변수로 초기화 하는게 좋음

해제할 때는 delete를 이용 스마트 포인터를 이용하지 않았다면 반드시 delete를 해주어야함

#### new VS malloc
- malloc은 라이브러리 제공함수 라이브러리를 추가해주어야함 new는 기본 함수로 그냥 사용가능
- malloc은 동적할당만을 위한 목적이기 때문에 초기화가 불가능
- new는 생성자를 자동으로 호출
- realloc을 통해 재할당이 가능하지만 new는 복잡한 과정을 따로 해주어야함

#### 메모리 풀
고정된 메모리를 미리 할당하고 이 메모리를 가져다가 사용하고 반납하는 방식
지속적으로 사용한다면 매우 효율이 좋음

#### 스마트 포인터
동적으로 할당한 메모리를 관리하기 쉬움

객체의 생명 주기를 자동으로 관리하여 메모리 누수를 방지
- 메모리 누수를 방지하려면 스마트 포인터를 적극활용하는게 좋음

unique_ptr
- 단일 소유권을 가지고 소유권을 명시적으로 이동 가능
    - std::move 를 사용
- 이 포인터가 어떤 포인터를 가지고있으면 다른 포인터가 이걸 가져갈수 없음

shared_ptr
- 참조 카운팅을 사용 여러 개의 포인터가 같은 자원을 고유 할 수 있음 
- 마지막 Shared_ptr이 소멸되면 메모리가 해제됨
- 래퍼런스 포인터를 하나씩 올렸다가 내림

weak_ptr
- shared_ptr과 함께 사용되며 순환 참조를 방지
- 자원을 획득하지만 소유권을 가지지 않음
- 래퍼런스 포인터를 올리지 않음
- 객체 생존 여부 확인 할 때
- 순환 참조 문제를 방지하는데에

### RAII ( Resource Acquisition Is Initialization )
자원의 획득과 해제를 객체의 생성과 소멸 시점에 맞추는 기법
- 생성자에서 자원을 획득
- 소멸자에서 자원을 해제

### 댕글링 포인터
    포인터가 여전히 해제된 메모리 영역을 가리키고 있는 포인터

메모리를 해제 하고나서도 포인터가 해당위치를 참조하고 있는 상황

- 메모리 접근시 예측 불가능한 동작
 
- 메모리 접근 불가 시 Segmentation fault
 
- 잠재적인 보안 위험

#### 최소화 시키기
- 포인터 해제 이후 null로 초기화

### void * (void 포인터)
    포인터인데 타입이 없는 포인터

주소값을 저장하지만 주소값만 저장하기 때문에 어떠한 타입이 들어있는지 알 수 없음

때문에 형변환을 통해 해당 주소에 접근을 해야함


## 모던 c++
c++11 이후의 버전들을 말한다.

기존의 C와 호환이 가능함과 동시에 더 간단하고 안정적이고 빠른 코드를 제공한다.

기능들은 버전이 높아지면서 점점 추가가 된다.

### 추가된 기능들 몇 가지

- auto
    - 컴파일러가 선언된 변수 또는 람다 식 변수의 초기화 식을 사용하여 타입을 추론하는 키워드
- using
    - namespcae 와 별칭 선언시 사용할 수 있게 되는 키워드
        - C++11 이전 typedef c++이후 using
        - typedef pair<int,int> pii;
        - using pii = pair<int,int>;

- 범위 기반 for문
    - 컨테이너에 있는 모든원소를 순차적으로 접근하는 반복문
    - 이터레이터로 접근하기에 범위가 begin()과 end()로 정의되는 것이어야함

- 람다 표현식
    - 이름없는 함수 객체를정의하는 방법
    - 함수의 포인터 또는 함수 객체를 대체할수있음
    - ex) auto square = [](double) { reutnr a * a};
    - ex) square(1.5)

    - 구현부나 선언부가 필요 없기 때문에 가독성이 좋아짐
    - 다른 클래스나 이런 곳에서 이 함수를 사용할 수 없기 때문에 이걸 난발하면 좋지 않음
    - 아마 간단한 수학식을 쓸 때

- Closure
    - 람다 표현식에 대한 런타임 결과는 오브젝트의 생성 이러한 오브젝트를 클로져라고 함
    - 람다가 클래스 클로져가 인스턴스 같은 느낌
    - 위의 예제에서 square는 복사본이지 클로져가 아님
        - 클로져는 해당 줄의 마지막에서 파괴됨
    

- chrono 라이브러리
    - OS독립적으로 정밀한 시간을 측정할 수 있게해주는 라이브러리
    - < chrono >에 정의되어있음
    - 나노초까지 측정가능

## C++ Template
프로그래머가 원하는 타입을 넣어주면 알아서 코드를 찍어내는 틀과 같은 것

컴파일 시점에 타입 독립적인 코드를 생성하는 기능

함수와 클래스를 다양한 타입으로 쉽개 재사용이 가능함

## C++ Template VS C# Generic class
- C++ 템플릿은 1번의 컴파일 C# 제네릭은 두번의 컴파일 과정을 거침
    - C++ 템플릿은 사용하지 않으면 컴파일 되지 않음 -> 커파일 시점에 타입을 결정
    - C# 제네릭은 사용하지 않아도 메타데이터가 생성됨 -> 런타임 시점에 타입을 결정

- 제네릭에서는 비타입 템플릿 매개변수를 허용하지 않음
    - template c<int i> {} 이런거
    - 비타입 매개변수
        - 정수, 포인터 , 참조 등
    - 타입 매개변수
        - typename T 같은거
        
- 지정한 타입인 경우에만 다르게 동작하도록하는 Template Specialization은 제네릭에서는 불가능
    - T로 선언 했지만 int형으로 미리 선언되어있다면 int형으로 선언되어있는걸 사용하는 것

# C++ 와 C#의 차이점
- 둘다 객체 지향 언어이지만 C#은 모든 것을 객체로 취급하기 때문에 컴포넌트 지향 프로그래밍 언어라고도 함
    - 컴포넌트
        - 재사용이 가능한 각각의 구성 요소 ( 독립된 모듈 )
        - 레고 불록과 같이 이미 만들어진 컴포넌트들을 조합하여 구성가능

    - 객체지향은 ***클래스 간의 연관성*** 에 초점을 맞추지만 컴포넌트 지향은 ***자체적으로 작동하는 교환 가능한 모듈***을 가용한다는 것

- C++는 컴파일시 기계코드로 직접 변환하지만 C#은 중간언어로 번환됨

- C++ 메모리를 수동으로 처리 C#은 갈비지컬렉터가 자동으로 처리

- C#에서는 포인터를 사용할수 없음

# Primitive type VS Reference type

## Primitive type
원시 타입이라고도 하며 정수 실수 문자 논리 리터럴 등의 실제 데이터 값을 저장하는 타입

변수에 값을 저장

- int , float, double 등등

## Reference type
참조 타입이라고도 하며 객체를 참조하는 타입

메모리 번지 값을 통해 객체를 참조하는 타입

메모리 상에 객체가 있는 위치를 저장

- pointer나 클래스가 있음

## 차이점
- null 값 저장 및 제네릭 타입
    - Primitive는 null값을 저장할 수 없다
    - Primitive는 제네릭 타입에서 사용할 수 없음
- 접근 속도
    - Primitive가 더 빠르다
        - stack 메모리에 값이 존재
        - stack에 참조값만 있고 실제로는 heap영역에 존재

# 객체 지향
    프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체로 만듬
    객체들 간의 상호작용을 통해 로직을 구성하는 프로그래밍 방법

## 특징
- 추상화
    - 공통적으로 필요로 하는 속성이나 동작을 본질에 착안해서 하나로 만들어내는 작업
    - 세부사항은 제거하고 가장 본질적이고 공통적인 부분만을 추출
- 캡슐화
    - 데이터와 메서드를 하나의 단위로 묶어 외부에서 접근하지 못하도록 보호하는 개념
    - 데이터 보호 , 은닉
- 상속
    - 기본의 클래스를 재활용하여 새로운 클래스를 작성하는 것
- 다형성
    - 어떤 객체의 속성이나 기능이 상황에 따라 여러 가지 형태를 가질 수 있는 성질

## 장점
- 모듈화,캡슐화로 인해 유지보수가 용이
- 재사용에 용이

## 단점
- 대부분의 객체지향 프로그램은 속도가 상대적으로 느리고 메모리를 많이 사용
- 설계 및 작성하는 데 시간이 다소 걸림