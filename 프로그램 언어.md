# C#
마이크로소프트사에서 닷넷(.NET) 프레임워크를 기반으로 개발한 프로그래밍 언어

C++기반으로 비주얼베이직의 편의성을 결합하여 만든 객체지향 프로그래밍 언어

사용자 친화성, 객체 지향성, 다중성의 특징을 가지고있음

## setter
setter는 C#의 속성(Property) 에서 값을 설정할 때 호출되는 블록
즉, 객체의 내부 변수(필드)에 값을 할당하는 역할을 함.

대입 연산자의 = 이 호출되면 value 변수를 할당하고 여기에 값을 저장 후 속성으로 이동해서 값을 변경
그냥 변수의 값을 대입하면 setter가 호출되지 않지만 프로퍼티에서 값을 대입하게 되면 setter에 의해서 값이 저장되고 필드의 값을 변경하게됨

### 프로퍼티
프로퍼티는 C++에서 getter setter를 정의하는 것과 같은것으로 c++에서는 따로따로 함수를 구현해야하지만

C#에서는 프로퍼티라는 하나의 함수로 get set 키워드를 이용해서 한번에 구현이 가능함

c++의 getter setter가 c#에서는 프로퍼티로 간단하게 구현이 가능한 것임


# C# List
vector가 없는거 같아서 찾아 보니깐 리스트가 이를 대체하는거 같다.

값 추가 하는 법
- 리스트는 Add로 값을 추가 
-  Insert로 특정 인덱스에 값을 추가 
- AddRange로 특정 범위의 값을 추가

C++의 list보다는 vector가 C#의 리스트와 유사함

차이점 C#               |     C++ 
-    동적 배열          |  이중연결리스트
-    연속된 메모리블럭   | 비연속적인 노드
-    인덱스 접근 가능   | 인덱스 접근 불가능

## 이중으로 리스트 선언시
List<int>[,] = new List<int>[3,3];으로 선언을 했는데 안의 내용이 다 null로 되어있음

때문에 나중에 접근하려고 하면 NullReferenceException 발생

### 왜 그럴까?
Reference Type은 처음 할당될 때 null로 할당을 해줌 그렇기 때문에 따로 각 행렬에 할당을 다시 해주어여함

C++는 자동으로 할당을 해주지만 C#에서는 자동으로 할당을 해주지 않음

즉 List<int>[3,3]은 메모리에 올라가있지만 그 안의 객체들은 메모리에 올라가있지 않아서 할당해주어야함

그래서 해당 위치에 객체들을 메모리할당 해주어야함


## Generic ( Generic class )
코드의 재사용성과 유연성을 향상해주는 도구

데이터 형식을 일반화하여 재사용가능한 코드를 작성할 수 있게 도와줌
- 여러 데이터 형식에 대해 동일한 로직을 적용할 때
- 다양한 데이터 형식을 저장하고 관리
- 데이터 형식에 따라 다른 연상을 수행할 때

C++의 템플릿클래스와 비슷한 기능으로 데이터를 일반화 해서 다양한 데이터에 맞게 사용

타입을 특정하지 않는 어떤 연산을 해주는 것 주로 제네릭 클래스를 사용
#### 제약 where
타입 파라미터가 값,참조,클래스,인터베이스를 구현한 타입인지를 지정할 수 있음

- 제약을 걸어 사용자가 원하지 않는 형식을 매개변수를 받지 않을 수 있음

즉 어떤 조건을 주는 것임

클래스만 제네릭이 가능 , 런타임때 확인 가능

## Coroutine
    실행의 지연과 재개를 허용함으로써 비선점적 멀티 태스킹을 위한 서부르틴을 일반화한 컴퓨터프로그램 구성요소

매우 어렵게 설명되어있지만 간단하게 말하면 협력성 멀티 태스킹

비동기 코드를 구현하기 위한 방법 중 하나 (스레드를 사용하지 않음)
중간에 일시 중지되어 다른 코두틴을 실행하고 나중에 중단한 지점부터 계속해서 실행됨

단일 스레드에서 자원을 나누어 사용 재개되는 시점에서 이전 스택이나 메모리를 저장해 두었다가 가져다가 사용됨

비선점적 멀티 태스킹: 쓰레드와 다르게 할당 받으면 종료되기 전까지 다른 프로세스가 강제로 cpu를 차지하지 못함

   - 병행성은 제공하지만 병렬성은 제공하지 않음

코루틴은 집입 후 반환문이 없더라도 임의의 지점에서 실행 중 동작을 중단하고 이후에 해당 지점에서부터 실행을 재개할 수 있음

싱글 쓰레드에서 돌아가는 하나의 함수 같은 것

싱글 쓰레드에서 비동기성을 만들어주는 것

하나의 쓰레드에서 여러개의 함수를 돌리수 있게 해줌

어째든 절차적으로 접근을 하기 때문에 무조건적 동기화 기법이 적용되지 않음 필요하면 사용 가능

### 특징
1. 중단과 재개: 코루틴은 실행을 중단,재개,종료할 수 있음 
    - yield : 코루틴을 일시 정지
    - await : 중단 및 재개
    - return : 종료
2. 협력형 멀티태스킹: 실행 시간을 공유함
    - 하나의 코루틴이 실행을 중단하면 다른 코루틴이 실행을 계속할 수 있음
3. 상태 보존: 중단 시점의 상태를 보존하여 다음 재개 시점부터 이전 상태를 그대로 이어서 실행

### 그 외
쓰레드와는 다른 개념

가독성이 올라감에 따라 유지보수성 상승

성능 증가

즉 컨텍스트 스위칭이 일어나지 않음 하나의 스레드에서 함수가 정지 되었다가 재개 되는 것임


# C++
C언어 기반으로 만들어졌으며 C언어를 개선함과 동시에 객체지향 프로그래밍 기능을 추가

## 생성자,소멸자 호출
생성자와 소멸자는 c++에서 클래스를 사용할 때 중요한 개념

### 생성자
클래스의 인스턴스가 생성될 때 자동으로 호출되는 특별한 함수

클래스와 객체지향 프로그래밍의 핵심 구성요소

클래스를 정의할 때 생성자를 이용해서 어떻게 초기화 할지 결정할 수 있음
- 생성자는 보통 클래스와 돌일한 이름을 가짐 
- 리턴타입을 명시하지않음
    - 생성자는 인스턴스를 생성하기 떄문

- 기본 생성자, 매개변수 생성자 , 복사 생성자같이 여러 형태가 존재
### 소멸자
클래스의 객체가 메모리에서 제거될 때 자동으로 호출되는 특별한 함수
- 클래스와 객체의 생명주기를 관리하는 큰 역할

소멸자는 생성자와같이 클래스와 동일한 이름을 가지지만 앞에 '~'가 붙음

한 클래스에서 단 하나만 존재함

### 생성자와 소멸자의 역할
- 생성자
    - 객체 초기화
        - 인스턴스가 생성될 때 멤버 변수가 생성자에의해서 초기화됨
    - 리소스 할당
        - 객체가 필요로하는 리소스나 일련의 사전 작업이 이루어짐
- 소멸자
    - 리소스 해제
        - 할당 받은 리소스 들을 해제해서 메모리 누수문제를 방지
    - 마무리 작업
        - 객체가 더 이상 필요하지 않을 때, 마무리 작업

### 객체 생성과 소멸 순서
무조건 생성자가 먼저 호출되고 나중에 소멸자가 호출됨

객체안에 다른 객체가 존재 한다면?

A객체 안에 B객체가 존재한다면

A객체의 인스턴스가 생성되고 인스턴스가 소멸할 때

A의 생성자 -> B 생성자 -> B 소멸자 -> A 소멸자

부모 생성자 -> 자식 생성자 -> 자식 소멸자 -> 부모 소멸자

## 디폴트 생성자
    Point::Point() { }

컴파일러가 자동으로 생성하는 일반 생성자

## 복사 생성자
    Point::Point(const Point& obj)
    {
	    x = obj.x;
        y = obj.y;
    }

객체를 복사하기 위해 사용되는 특수한 형태의 생성자

한 객체의 내용을 다른 객체로 복사하여 생성된 생성자

생성자를 호출하는 객체와 동일한 타입의 객체를 인자로 받아 동일하게 객체를 구성하는 생성자

- 자신과 같은 타입의 객체를 인자로 받음
- 복사 생성자가 정의 되어있지 않으면 디폴트 복사 생성자가 생성됨

### 호출되는 시기
1. 객체가 다른 객체로 초기화될 때
2. 객체가 함수의 매개변수로 전달될 때
3. 객체가 함수의 반환값으로 반환될 때

## 얕은 복사 , 깊은 복사
### 얕은 복사
- 객체의 멤버 변수만 복사
- 멤버 변수가 포인터인 경우 포인터 주소만 복사
- 두 객체가 동일한 메모리 주소를 참조

### 깊은 복사
- 클래스 자체를 복사
- 객체의 멤버변수가 포인터의 경우 포인터가 가리키는 실제 데이터도 복사
- 두 객체가 각각 독립적인 메모리 공간을 가짐

## 오버라이딩, 오버로딩
    다형성을 챙기기 위한 방법
### 오버라이딩
상위 클래스의 메소드를 하위 클래스에서 재정의 하는것
- 반환값이나 매개변수 모두 똑같이 하고 정의 해야함

### 오버로딩
메소드 이름은 같지만 매개변수의 타입이나 갯수를 다르게해서 중복으로 정의하는 것
- 반환값만 다르게 해서 정의할 수 없음

## 함수 재정의 & 함수 오버라이딩
### 함수 재정의
부모 클래스에서 정의된 함수를 자식 클래스에서 동일한 형식의 함수를 정의하는 것
- 동일한 형식 : 리턴값, 매개변수의 타입 및 갯수 ,메소드 이름을 모두 같은 것
- 재정의한 함수를 부모 클래스의 포인터로 접근하면 부모 클래스의 함수가 호출됨, 자식 클래스 포인터로 접근하면 자식클래스의 함수가 호출
- 호출시 해당 포인터의 클래스에 함수로 호출되기 때문에 컴파일 시점에서 결정됨 -> 정적 바인딩

### virtual 함수 ( 가상 함수 )
virtual 키워드로 선언된 함수
- virtual : 컴파일러에게 자신에 대한 호출 바인딩을 런타임까지 미루도록 지시하는 키워드

- 순수 가상함수 
    - 상속받은 자식 클래스에서 반드시 오버라이딩을 해야함
    - 인스턴스는 생성 할 수 없음

### virtual 소멸자
다형성을 구현하기 위함 구체적으로 동적 바인딩을 위함

부모 클래스에 virtual 소멸자가 존재한다면 자식것도 같이 호출이 되지만 없다면 부모만 호출이 됨

- 부모 클래스의 소멸자에 virtual 키워드가 있다면
    - 상속받은 자식에서 오버라이드된 소멸자를 호출하면 부모 클래스의 소멸자가 호출됨

- 부모 클래스의 소멸자에 virtual 키워드가 없다면
    - 부모 클래스의 소멸자만 호출되고 자식 클래스의 소멸자는 호출이 되지 않음
    - 정적 바인딩이 이루어져서 객체의 타입에 상관없이 부모 클래스의 소멸자가 호출됨

그렇게 되면 자식 객체의 소멸자가 호출되지 않기 때문에 메모리 누수가 발생 됨

자식소멸자 메모리 해제 단계가 있을 때 중요함

### 함수 오버라이딩
기본 클래스 즉 부모 클래스 앞에 virtual이라는 키워드를 붙이고 동일한 형식의 함수를 정의하는 것
- virtual을 붙여서 동적 바인딩을 한다는 뜻임
- 기본 클래스의 포이터든 파생 클래스의 포인터든 어떤걸 이용하든 가상함수를 호출하면 파생클래스의 함수가 호출됨

### RTTI
    Run time type Information 의 약자로 프로그램 실행중에 실시간으로 데이터의 타입을 얻어올 때 사용하는 방법

#### typeid( param p )
 RTTI는 typeid 연산자에 데이터나 타입을 담아서 정보를 얻어올 수 있고 type_info로 반환 된다.

 - name()을 통해 해당 타입의 이름을 받아올 수 있음

- dynamic_cast , virtual에서 사용되고 있음

## C++ Template
프로그래머가 개별적으로 작성하지 않아도 원하는 타입을 넣어주면 알아서 코드를 찍어내는 틀과 같은 것

컴파일 시점에 타입 독립적인 코드를 생성하는 기능

함수와 클래스를 다양한 타입으로 쉽개 재사용이 가능함

## C++ Template VS C# Generic class
- C++ 템플릿은 1번의 컴파일 C# 제네릭은 두번의 컴파일 과정을 거침
    - C++ 템플릿은 사용하지 않으면 컴파일 되지 않음 -> 커파일 시점에 타입을 결정
    - C# 제네릭은 사용하지 않아도 메타데이터가 생성됨 -> 런타임 시점에 타입을 결정

- 제네릭에서는 비타입 템플릿 매개변수를 허용하지 않음
    - template c<int i> {} 이런거
    - 비타입 매개변수
        - 정수, 포인터 , 참조 등
    - 타입 매개변수
        - typename T 같은거
        
- 지정한 타입인 경우에만 다르게 동작하도록하는 Template Specialization은 제네릭에서는 불가능
    - T로 선언 했지만 int형으로 미리 선언되어있다면 int형으로 선언되어있는걸 사용하는 것

### Template Meta Programing ( TMP )
일반화 프로그래밍 ( generic programming )이라고도 함

템플릿 인자로 타입뿐만 아니라 특정한 조건을 만족하는 값이 올 수 있음

객체를 생성하지 않더라도 타입에 어떠한 값을 부여할 수 있고 또 그 타입들을 가지고 연산을 할 수 있다

컴파일 타임에 확정되야하므로 모든 연산은 컴파일 타임에 끝남

타입을 가지고 컴파일 타임에 생성되는 코드로 프로그래밍을 하는 것을 *** 메타 프로그래밍 ***이라고 함

C++에서는 이를 템플릿을 가지고 이러한 작업을 하기 때문에 *** 템플릿 메타 프로그래밍 *** 이라고 함

#### 사용하는 이유?
- 컴파일 단계에서 모든 연산이 끝나기 때문에 프로그램 실행 속도를 향상 시킬 수 있음 ( 컴파일 시간은 느러남 )
- 단점도 존재함
    - 디버깅이 어려움
        - 런타임 때 결정되지 않기 때문에 찾기 힘듬
        - 코드도 복잡해짐

## C++ 메모리 관리
c++는 수동으로 메모리를 관리가 가능
그만큼 메모리 관리를 세세하게 할 수 있지만 잘 못할 경우 메모리 누누나 이중해제등 심각한 문제를 초래할 수 있음

### 스택,힙 메모리
- 스택 메모리: 함수 호출시 자동으로 할당 종료시 자동으로 해제
- 힙 메모리 : 동적 할당 및 해제 메모리로 개발자가 명시적으로 할당하고 해제해야함

### 수동 메모리 관리
메모리를 계속 할당하면 오버헤드가 발생
new 가 그냥 발생함 메모리 쓸거야 , 어디 줘 , 등등 때문에 

메모리 할당할 때 오버헤드를 신경써주어야함

#### new delete
c++에서 기본적으로 동적 할당을 할때 new 연산자를 이용
- 힙 메모리에 할당됨
- 포인터 변수를 선언하면 nullptr이나 포인터 변수로 초기화 하는게 좋음

해제할 때는 delete를 이용 스마트 포인터를 이용하지 않았다면 반드시 delete를 해주어야함

#### new VS malloc
- malloc은 라이브러리 제공함수 라이브러리를 추가해주어야함 new는 기본 함수로 그냥 사용가능
- malloc은 동적할당만을 위한 목적이기 때문에 초기화가 불가능
- new는 생성자를 자동으로 호출
- realloc을 통해 재할당이 가능하지만 new는 복잡한 과정을 따로 해주어야함

#### 메모리 풀
고정되고 연속된 메모리 공간을 미리 할당하고 이 메모리를 가져다가 사용하고 반납하는 방식
지속적으로 사용한다면 매우 효율이 좋음

#### 포인터
다른 변수의 메모리 주소를 가리키는 변수

#### 스마트 포인터
동적으로 할당한 메모리를 관리하기 쉬움 특정 조건에 의해 메모리가 자동을 해제 됨

객체의 생명 주기를 자동으로 관리하여 메모리 누수를 방지
- 메모리 누수를 방지하려면 스마트 포인터를 적극활용하는게 좋음

unique_ptr
- 단일 소유권을 가지고 소유권을 명시적으로 이동 가능
    - std::move 를 사용
- 이 포인터가 가리키고 있는 공간을 다른 포인터가 가리킬수 없음

shared_ptr
- 참조 카운팅을 사용 여러 개의 포인터가 같은 자원을 고유 할 수 있음 
- 마지막 Shared_ptr이 소멸되면 메모리가 해제됨
- 래퍼런스 포인터를 하나씩 올렸다가 내림

weak_ptr
- shared_ptr과 함께 사용되며 순환 참조를 방지
- 자원을 획득하지만 소유권을 가지지 않음
- 래퍼런스 포인터를 올리지 않음
- 객체 생존 여부 확인 할 때
- 순환 참조 문제를 방지하는데에

### RAII ( Resource Acquisition Is Initialization )
자원의 획득과 해제를 객체의 생성과 소멸 시점에 맞추는 기법
- 생성자에서 자원을 획득
- 소멸자에서 자원을 해제

### 댕글링 포인터
    포인터가 여전히 해제된 메모리 영역을 가리키고 있는 포인터

메모리를 해제 하고나서도 포인터가 해당위치를 참조하고 있는 상황

- 메모리 접근시 예측 불가능한 동작
 
- 메모리 접근 불가 시 Segmentation fault
 
- 잠재적인 보안 위험

#### 최소화 시키기
- 포인터 해제 이후 null로 초기화

### void * (void 포인터)
    포인터인데 타입이 없는 포인터

    타입이라기 보다는 주소값을 저장하는 포인터

주소값을 저장하지만 주소값만 저장하기 때문에 어떠한 타입이 들어있는지 알 수 없음

때문에 형변환을 통해 해당 주소에 접근을 해야함


## 모던 c++
c++11 이후의 버전들을 말한다.

기존의 C와 호환이 가능함과 동시에 더 간단하고 안정적이고 빠른 코드를 제공한다.

기능들은 버전이 높아지면서 점점 추가가 된다.

### 추가된 기능들 몇 가지

- auto
    - 컴파일러가 선언된 변수 또는 람다 식 변수의 초기화 식을 사용하여 타입을 추론하는 키워드
- using
    - namespcae 와 별칭 선언시 사용할 수 있게 되는 키워드
        - C++11 이전 typedef c++이후 using
        - typedef pair<int,int> pii;
        - using pii = pair<int,int>;

- 범위 기반 for문
    - 컨테이너에 있는 모든원소를 순차적으로 접근하는 반복문
    - 이터레이터로 접근하기에 범위가 begin()과 end()로 정의되는 것이어야함

- 람다 표현식
    - 이름없는 함수 객체를정의하는 방법
    - 함수의 포인터 또는 함수 객체를 대체할수있음
    - ex) auto square = [](double) { reutnr a * a};
    - ex) square(1.5)

    - 구현부나 선언부가 필요 없기 때문에 가독성이 좋아짐
    - 다른 클래스나 이런 곳에서 이 함수를 사용할 수 없기 때문에 이걸 난발하면 좋지 않음
    - 아마 간단한 수학식을 쓸 때

- Closure
    - 람다 표현식에 대한 런타임 결과는 오브젝트의 생성 이러한 오브젝트를 클로져라고 함
    - 람다가 클래스 클로져가 인스턴스 같은 느낌
    - 위의 예제에서 square는 복사본이지 클로져가 아님
        - 클로져는 해당 줄의 마지막에서 파괴됨
    

- chrono 라이브러리
    - OS독립적으로 정밀한 시간을 측정할 수 있게해주는 라이브러리
    - < chrono >에 정의되어있음
    - 나노초까지 측정가능



# C++ 와 C#의 차이점
- 둘다 객체 지향 언어이지만 C#은 모든 것을 객체로 취급하기 때문에 컴포넌트 지향 프로그래밍 언어라고도 함
    - 컴포넌트
        - 재사용이 가능한 각각의 구성 요소 ( 독립된 모듈 )
        - 레고 불록과 같이 이미 만들어진 컴포넌트들을 조합하여 구성가능

    - 객체지향은 ***클래스 간의 연관성*** 에 초점을 맞추지만 컴포넌트 지향은 ***자체적으로 작동하는 교환 가능한 모듈***을 가용한다는 것

- C++는 컴파일시 기계코드로 직접 변환하지만 C#은 중간언어로 번환됨

- C++ 메모리를 수동으로 처리 C#은 갈비지컬렉터가 자동으로 처리

- C#에서는 포인터를 사용할수 없음

# Primitive type VS Reference type

## Primitive type
원시 타입이라고도 하며 정수 실수 문자 논리 리터럴 등의 실제 데이터 값을 저장하는 타입

변수에 값을 저장

- int , float, double 등등

## Reference type
참조 타입이라고도 하며 객체를 참조하는 타입

메모리 번지 값을 통해 객체를 참조하는 타입

메모리 상에 객체가 있는 위치를 저장

- pointer나 클래스가 있음

## 차이점
- null 값 저장 및 제네릭 타입
    - Primitive는 null값을 저장할 수 없다
    - Primitive는 제네릭 타입에서 사용할 수 없음
- 접근 속도
    - Primitive가 더 빠르다
        - stack 메모리에 값이 존재
        - stack에 참조값만 있고 실제로는 heap영역에 존재

# 객체 지향
    프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체로 만듬

    여러 개의 독립된 객체(object)들로 나누어 설계하고 구현하는 방식
    
    객체들 간의 상호작용을 통해 로직을 구성하는 프로그래밍 방법


## 왜 사용하는지?
코드 재사용성 때문에
코드 재사용성이란? 코드를 재사용할 수 있는 기능
상속과 클래스 구조를 통해 코드의 재사용성을 높일 수 있음

코드 재사용성이 왜 유지 보수에 도움이 되는지 -> 문제가 생겼을 때 하나만 변경하면 되기 때문에

## 특징
- 추상화
    - 공통적으로 필요로 하는 속성이나 동작을 본질에 착안해서 하나로 만들어내는 작업
    - 세부사항은 제거하고 가장 본질적이고 공통적인 부분만을 추출
- 캡슐화
    - 데이터와 메서드를 하나의 단위로 묶어 외부에서 접근하지 못하도록 보호하는 개념
    - 데이터 보호 , 은닉
- 상속
    - 기본의 클래스를 재활용하여 새로운 클래스를 작성하는 것
- 다형성
    - 어떤 객체의 속성이나 기능이 상황에 따라 여러 가지 형태를 가질 수 있는 성질

## SOLID원칙

### SRP 단일 책임 원칙
작성된 클래스는 하나의 기능만 가지며 클래스가 제공하는 기능은 하나의 책임을 수행
### OCP 개방폐쇄의 원칙
확장는 쉽게 변경은 어렵게
### LSP 리스코브 치환의 원칙
하위 타입은 상위 타입으로 대체될 수 있어야한다.
### ISP 인터페이스 분리의 원칙
목적과 관심이 각기 다른 클라이언트가 있다면 인터페이스를 통해 적절하게 분리
### DIP 의존성역전의 원칙
고수준 모듈은 저수준 모듈에 의존해선 안되고 저수준 모듈이 고수준 모듈에 의존되어야함

## 장점
- 모듈화,캡슐화로 인해 유지보수가 용이
- 재사용에 용이

## 단점
- 대부분의 객체지향 프로그램은 속도가 상대적으로 느리고 메모리를 많이 사용
- 설계 및 작성하는 데 시간이 다소 걸림

# Call by Value, Call by Reference

## Call by Value
함수 호출 시 넘기는 인자의 값이 매개변수에 복사(Copy)돼서 함수 내에서 매개변수에 직접적인 데이터 조작을 가해도 인자에 전혀 영향을 주지 않는 것
- 원본 값이 들어온것이 아니기 때문에 인자값을 수정해도 원본 값은 그대로임

## Call by Reference
함수 호출 시 넘기는 인자의 값이 매개변수에 복사(Copy)된다는 점은 동일 다만 복사되는 값이 데이터의 주소 값이라는 차이점
- 주소값이 복사 되기에 넘겨진 인자값을 수정하면 원본 값도 수정됨

# goto문
goto문은 cpu가 코드의 다른 지점으로 점프하도록하는 제어 흐름 명령문

점프하는 지점은 문 라벨 ":"을 사용하여 식별
- goto와 동일한 블록에서 초기화된 변수 앞으로 건너 뛸수 없음

## 특징
- 일반적으로 goto는해로운 코드로 간주 때문에 거의 사용되지 않음
    - 실행지점을 뛰어넘게 하기 때문에 스파게티 코드를 만들게 됨
    - 흐름을 강제적으로 변경하기 때문에 좋지 못함

# struct vs class
사용자 데이터 타입을 정의 할 때 사용됨
멤버와 함수를 가질 수 있음

## struct
데이터의 집합체로 사용됨

기본접근 지정자로 public으로 정의

## class
객체지향 프로그래밍에서 객체의 정의를 위해 사용됨

기본접근 지정자로 private로 정의

상속 다형성 및 갭슐화와 같은 객체지향 개념을 더 잘 지원

기본 명시자가 다름 class는 private, struct는 public임

# class vs interface

## 클래스
객체의 구조와 동작을 정의할 수 있음
- 속성과 메서드를 포함
- 인스턴스를 생성할 수 있음

- 클래스는 상속하는 곳

### 추상클래스
순수 가상함수가 하나 이상있는 경우를 추상 클래스라고 함

인스터스화 할수 없는 클래스

## 인터페이스
클래스가 구현해야 하는 메서드의 목록을 정의
- 구현 자체를 포함하지 않음

선언부가 아예 없는 클래스를 인터페이스라고 함
- 생성자를 제외한 모든 함수가 순수 가상함수로 이루어져있음

인터페이스를 통해 다중 상속을 구현 할 수 있음
구현하는 곳

클래스를 상속하고 인터페이스는 구현함

클래스는 부모자식 관계지만 인터페이스는 관계성이 약함

왜 사용함??
어떤 부모자식과의 관계가 아니지만 다형성을 형성하고 싶을 떄

# overflow , underflow
    표현할 수 있는 범위에서 최소값 미만인 경우 underflow 최대값 이상인 경우 overflow라고 함

표현 가능한 최대 범위에서 값이 더해질 경우 부호를 결정하는 가장 앞의 비트( 최상위 비트 MBS )가 변화하면서 양수가 음수로 변함 이를 overflow라고 함

# Parallel class
병렬처리를 쉽게 구현할 수 있도록 도와주는 클래스

# Parallel.for
.NET 프레임워크에서 제공하는 메서드로, 반복 작업을 병렬로 실행할 수 있도록 도와 줌

다중 쓰레드로 반복문을 병렬처리하는 거기 때문에 순서의 영향을 받지 않음
- for문을 돌리지만 i를 출력했을 때 i가 1씩 증가하는게 아니라 랜덤하게 i가 찍힐 것임
- Parallel.For(0, 10, i => { ... })
- 복잡한 병렬처리를 효율적으로 처리가 가능

# Const
변수를 상수화 시키는 키워드
- 고정되어 있어야 할 값을 변수에 저장해서 사용하면 변할 가능성이 있기 때문에 이걸 고정 시키는 역할

- 변수 앞의 const
    - 변수의 값을 변경 할 수 없음
    - 타입 앞이든 변수명 앞이든 아무 상관 없음
        - const int t;
        - int const t;

- const 포인터 변수
    - 맨 앞에 위치할 때
        - 타입 앞에 존재하면 그 포인터를 상수화 시킨 것
            - 포인터 자체에 할당이 안됨
            - 이미 할당된 변수는 변경이 가능
            - const int* t;
    
    - 중간에 있을 때
        - 타입 뒤에 존재하는 것으로 포인터가 가리키는 주소를 변경하지 못함
        - 포인터 자체를 상수화 시킨것 다른 주소를 가리키게 할 수 없음
        - int* const t;
    
- 함수에서 포인터 변수 사용
    - 매개 변수 자료형에 사용될 경우
        - 함수 내에서 인자 값을 변경하고 싶지 않을 떄
    - 함수의 맨 뒤에 선언 될 경우
        - 함수 내에서 멤버 변수를 변경하지 못함
    - 함수의 맨 앞 리턴부분에 선언 될 경우
        - 반환 값을 상수화 시켜서 반환
        - 일반적으로는 의미 없지만 래퍼런스로 받을 때 사용

#  Friend class
    클래스에 대한 friend선언은 원본 클래스의 private,public, protected의 접근 권한을 또 다른 클래스에 넘겨주는 것

클래스 선언 시에 권한을 주고 싶은 클래스를 public 에서 선언 해주면됨 " firend class test; "

특정 함수만 프렌드화 해서 권한을 부여 해줄 수 도 있음

# argument, parameter
## argument
    매개변수 , 함수와 메서드 입력 변수명

## parameter
    함수와 메서드의 입력 값

## 가변 인자
    고정되지 않은 인자

    void func(int ...) {} 인자 뒤에 "..."을 붙여서 선언

원하는 타입을 입력한 만큼 받겠다는 의미

## 가변길이 템플릿
    template <typename T, typename... Types> 와 같이 선언이 가능

typename뒤에 있는 "..."으로 *** 템플릿 파라미터 팩 *** 이라고 함

마찬가지로 함수에 인자로 "..."이 있는데 이것은 *** 함수 파라미터 팩 *** 이라고함

- 템플릿 파라미터 팩
    - 0개 이상의 템플릿 인자들
- 템플릿은 타입 앞에 함수는 타입 뒤에 붙음
- 파라미터 팩은 추론된 인자를 제외한 나머지를 나타내게 됨

# loop Unrolling
    반복문 최적화 기법중 하나

    반복문 안의 코드를 반복 횟수만큼 여려 번 복사하여 루프 제어코드를 줄임으로써 성능을 향상

## 장점
- 성능 향상
    - 반복 제어 코드가 줄어 cpu 사용량 감소
> for문을 이용하면 반복 횟수 확인 및 인덱스 증가 연산이 이루어짐

- 병렬 처리 가능성 증가

## 단점
- 스파게티 코드
- 코드 크기 증가
- 유지 보수의 어려움

자동으로 언롤링 하는 경우도 있음

# explicit
    생성자와 형변환 연산자에서 사용

암시적 변환을 방지, 코드의 가독성과 안전성을 높임

## 생성자에서의 explicit
생성자에 explicit 키워드를 붙이면 해당 생성자는 암시적 형 변환을 허용하지 않음
>단일 인수를 가지거나, 암시적 형변환이 가능한 경우, 프로그램의 예상치 못한 동작을 방지

생성자에 인수를 전달하는 것을 명시해야함

## 형변환 연산자에서의 explicit
형변환 연사자에 explicit 키워드를 사용하면 해당 연산자도 암시적 형 변환을 방지 ( 컴파일 단계에서 형변환이 되지 않도록 )

> 타입 변환을 명시적으로 수향 하도록 강제

explicit 키워드를 사용함으로 코드의 의도를 명확히 하고 타입 변환에서 발생할 수 있는 잠재적인 오류를 방지

# 전역변수와 정적변수

## 라이프 타임
둘다 모두 프로그램이 죽을 때 까지 살아있음

## 사용가능 범위
전역변수는 scope없는 곳에서 선언 함
모든 곳에서 사용이 가능하지만 다른 파일에서 사용하고자 한다면 extern을 붙여서 사용해야함

정적변수는 static이라는 키워드가 붙어야하며 선언된 scope에 따라서 접근 가능한 범위가 결정된다. 해당 파일의 scope에서만 접근이 가능 함

func 안에 정의 된게 아니라 밖에서 선언되면

scope는 파일 안에서만 사용가능 함 전역변수와 다른게 정적변수는 scope가 제한 될수 있음

정적 전역변수로 전역인 scope에 정적변수를 선언하는것
다른 파일에서 extern을 붙여도 사용할 수 없음

정적변수는 선언된 해당 파일에서만 사용이 가능함

## 메모리 할당
전역 변수는 선언이 되고 사용이 되든 되지 않든 메모리에 올라간다

정적 변수는 선언이 되더라도 사용되지 않으면 메모리에 올라가지 않는다.

# placement new

new 연산자는 기본적으로 C의 malloc과 달리 메모리 할당 + 초기화를 수행

메모리 할당은 해당 클래스 타입의 인스턴스를 저장할 공간을 할당받는 것이고 초기화는 생성자를 호출함으로 할당받은 메모리 공간에 인스턴스를 생성및 초기화함

이 두 과정을 분리하여 다루는 것이 Placement new

힙영역에서 메모리를 가져다 쓰는게 아니라 사용하길 원하는 메모리 공간을 지정할 수 있음

new 다음 괄호 안에 사용할 공간을 적어주면 됨

1. 인스턴스를 생성 및 초기화할 공간을 지정
2. 지정한 공간이 생성자를 호출
3. 지정한 공간에 인스턴스 생성 및 초기화

## 주의 할점
delete로 지워서는 안됨 해당 객체의 소멸자를 직접 호출해야함

## 장점
메모리 관리 측면이 아닌 초기화시 다른 객체와의 성정들을 하는 생성자가 원하는 순간에 할수 있음

메모리와 생성자를 부닐해서 따로 관리하기 위함

따로 다시 다 처음부터 공부 하기