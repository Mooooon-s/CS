# 레드블랙 트리
***자가 균형 이진 탐색 트리*** 

이진 탐색 트리는 균형이 맞지 않으면 최악의 경우 O(N)의 시간 복잡도를 가진다

레드블랙트리는 삽입 삭제하는 동안 균형이 잡도록하여 모든 경우에서 O(logN)의 시간 복잡도를 보장한다.

- C++의 map과 set 이 자료구조를 사용

## 레드-블랙 트리의 조건
1. 모든 노드는 빨간생 혹은 검은색
2. 루트 노드는 검은색
3. 모든 리프노드(NIL)은 검은색
4. 빨간색 노드의 자식은 검은색
    - No double red( 빨간색 노드가 연속 두번 나올 수 없음)
5. 모든 리프 노드에서 Black Depth는 같다
    - 리프에서 루트까지 만나는 검은색 노드의 개수는 같음

- recoloring이나 resturctering으로 이런 문제를 해결

더블 레드
    - 부모 쪽 레드를 오른쪽 왼쪽으로 회전 resturctering

# 해시 맵
키(key)와 값(value)를 한 쌍으로 저장하는 자료구조
- 각 키는 고유하며 키를 사용하여 해당하는 값을 빠르게 검색할 수 있다.

## 해싱(Hashing)
해싱 함수는 키를 받아서 정수값인 해시코드를 반환

반환된 해시코드는 Hash배열의 각요소인 버킷의 인덱스가 됨

## 특징
1. 키 기반의 빠른 접근 : 키를 사용하여 값을 빠르게 검색하거나 수정 가능
2. 순서를 보장하지 않음
3. 키의 중복 불가
4. null 키와 값 : 해시 맵은 null키와 null값을 저장할수있음
5. 유연성 : 어떤 객체든 키로 사용할 수 있음
6. 해시 충돌 : 두 개 이상의 키가 동일한 해시코드를 가질 때 충돌이 발생 -> 성능 저하

### 해시 충돌
해시코드를 만드는 과정에서 동일할 해시코드를 생성할 가능성이 존재
이렇게 같은 해시코드를 가지게되면 키가 다르더라도 같은 공간을 참조하게 되어 문제가 발생

- 해결방법
    - 체이닝
        - 각 버킷을 연결리스트로 구현하여 충돌이 발생하면 연결리스트에 새로는 키-값을 추가
    - 개방 주소법
        - 해시테이블의 배열에 직접 저장을 하고 충돌이 발생하면 다른 위치를 찾아 삽입 시도
    - 재해싱
        - 모든 키-값들을 다시 새로운 크기에 맞게 재삽입하는 방법
    - 버킷확장
        - 버킷의 크기를 확장하여 여러 키-값을 저장할 수있게함
    - 커스텀 해시 함수 사용
        - 해시합수를 직접 만들어서 사용