# 레드블랙 트리
***자가 균형 이진 탐색 트리*** 

이진 탐색 트리는 균형이 맞지 않으면 최악의 경우 O(N)의 시간 복잡도를 가진다

레드블랙트리는 삽입 삭제하는 동안 균형이 잡도록하여 모든 경우에서 O(logN)의 시간 복잡도를 보장한다.

- C++의 map과 set 이 자료구조를 사용

## 레드-블랙 트리의 조건
1. 모든 노드는 빨간생 혹은 검은색
2. 루트 노드는 검은색
3. 모든 리프노드(NIL)은 검은색
4. 빨간색 노드의 자식은 검은색
    - No double red( 빨간색 노드가 연속 두번 나올 수 없음)
5. 모든 리프 노드에서 Black Depth는 같다
    - 리프에서 루트까지 만나는 검은색 노드의 개수는 같음

- recoloring이나 resturctering으로 이런 문제를 해결

더블 레드
    - 부모 쪽 레드를 오른쪽 왼쪽으로 회전 resturctering

# 해시 맵
키(key)와 값(value)를 한 쌍으로 저장하는 자료구조
- 각 키는 고유하며 키를 사용하여 해당하는 값을 빠르게 검색할 수 있다.

## 해싱(Hashing)
해싱 함수는 키를 받아서 정수값인 해시코드를 반환

반환된 해시코드는 Hash배열의 각요소인 버킷의 인덱스가 됨

## 특징
1. 키 기반의 빠른 접근 : 키를 사용하여 값을 빠르게 검색하거나 수정 가능
2. 순서를 보장하지 않음
3. 키의 중복 불가
4. null 키와 값 : 해시 맵은 null키와 null값을 저장할수있음
5. 유연성 : 어떤 객체든 키로 사용할 수 있음
6. 해시 충돌 : 두 개 이상의 키가 동일한 해시코드를 가질 때 충돌이 발생 -> 성능 저하

### 해시 충돌
해시코드를 만드는 과정에서 동일할 해시코드를 생성할 가능성이 존재
이렇게 같은 해시코드를 가지게되면 키가 다르더라도 같은 공간을 참조하게 되어 문제가 발생

- 해결방법
    - 체이닝
        - 각 버킷을 연결리스트로 구현하여 충돌이 발생하면 연결리스트에 새로는 키-값을 추가
    - 개방 주소법
        - 해시테이블의 배열에 직접 저장을 하고 충돌이 발생하면 다른 위치를 찾아 삽입 시도
    - 재해싱
        - 모든 키-값들을 다시 새로운 크기에 맞게 재삽입하는 방법
    - 버킷확장
        - 버킷의 크기를 확장하여 여러 키-값을 저장할 수있게함
    - 커스텀 해시 함수 사용
        - 해시합수를 직접 만들어서 사용

# Tree
## tree의 정의
1개 이상의 유한한 개수의 노드의 집합

루트 노드와 겹치지 않는 하위 구조들의 집합으로 이루어짐

- 노드와 엣지로 표현됨
- path : 엣지로 의해 연결된 node들의 집합
- root node : 최상위 노드
- level : 트리의 계층
- leaf node : 자식이 없는 노드

## 트리 순회
트리를 차례로 방문하는 방법으로 부모 노드를 언제 방문하느냐로 순회 방법을 나눌 수 있음

### 전위 순회
루트에서 왼쪽 오른쪽 순으로 노드를 방문
- 자식 노드로 들어갈 수 있다면 계속 왼쪽 먼저 들어감

### 중위 순회
왼쪽 루트 오른쪽 순으로 노드를 방문
- 가장 왼쪽의 리프 노드 부터 왼쪽 -> 부모 -> 오른쪽 순으로 순회

### 후위 순회
왼쪽 오른쪽 루트 순으로 노드를 방문
- 가장 왼쪽의 리프 노드 부터 왼쪽 -> 오른쪽 -> 부모 순으로 순회

# Heap
완전 이진 트리의 일종으로 우선 순위 큐를 위해서 만들어진 자료구조

여러 개의 값들 중에서 최댓값이나 최솟값을 빠르게 찾아내도록 만들어진 자료구조

힙은 일종의 반정렬 상태를 유지
- 큰 값이 상위에 있고 작은 값이 하위에 있다는 정도
- 부모 노드의 키 값이 자식 노드의 키값보다 항상 큰거나 작은 이진 트리
- 힙에서는 중복된 값을 허용

## 종류
- 최대 힙
    - 부모 노드의 키값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리
    - 부모 노드 >= 자식 노드
- 최소 힙
    - 부모 노드의 키 값이 자식 노드의 키값보다 작거나 같은 완전 이진 트리
    - 부모노드 <= 자식 노드

## 구현
- 일반 적으로 배열을 이용해서 구현 가능
- 쉬운 구현을 위해 1번째 인덱스 부터 사용
- 부모 노드와 자식 노드의 관계
    - 왼쪽 자식 인덱스 = 부모 인덱스 * 2
    - 오른쪽 자식 인덱스 = 부모 인덱스 * 2 +1
    - 부모 인덱스 = 자식 인덱스 / 2 

## 삽입
- 일단 새로운 노드를 힘의 마지막 노드에 삽입
- 새 노드를 부모 노드들과 교환 해서 힙의 성질을 만족

## 삭제
- 삭제의 경우 루트 노드가 빠지는 경우 밖에 없음
1. 루트 노드를 삭제 
2. 맨 뒤에 있는 노드를 루트로 가져옴
3. 자식 노드 중 값이 더 큰 노드와 비교해서 교환하여 노드를 재정렬

- 삭제의 경우 시간 복잡도가 O(logN)을 가짐

# Stack
    LIFO의 형태를 지닌 자료구조
    쌓다라는 의미로 데이터를 하나씩 쌓아 올린 형태의 자료구조

정해진 방향으로만 접근이 가능함, Top으로 정한 곳을 통해서만 접근이 가능
- 삽입시 Top이 가리키는 가장 맨 위에 쌓이게 됨
- 삭제시 Top을 통해서 삭제가 됨
- 배열과 연결 리스트로 구현이 가능