# TArray
언리얼에서 가장 자주쓰이는 컨테이너 클래스 신속성, 메모리, 효율성,안정성을 염두하여 디자인됨

주로 두가지 프로퍼티로 구분되면 엘리먼트 와 할당자로 구분됨
- 엘리먼트
    - 엘리먼트는 배열에 저장되는 오브젝트 유형
    - TArray는 동질성 컨테이너로 저장되는 엘리먼트 유형이 엄격하게 같아야함

- 할당자
    - 할당자는 메모리에 오브젝트가 레이아웃 되는 방식 배열에 엘리먼트를 넣어 배열을 키우는 방식을 결정
    - 생략이 가능하지만 ( 기본값은 1 ) 대부분 적합한 값으로 사용됨

 ### 특징
 - 동적 크기 조정
    - STL vector 와 마찬가지로 동적 크기조정이 가능하다
    - Add Insert Remove 등의 함수
- 메모리 관리
    - TArray : 메모리 할당 및 해제를 최소화 하도록 최적화 되어있음
    - vector : 연속적인 메모리 블럭을 사용하여 효율적인 메모리 관리를 하지만 TArray와 다르게 최적화 기능이 있지는 않음

# UObject
클래스의 한 일종으로 언리얼의 모든 객체가 상속하는 Base Class

이 클래스를 상속받는 모든 클래스는 언리얼의 객체가 될 수 있음

> 언리얼 엔진에서 객체를 생성하고 관리하기 위한 기반 클래스

## UObject의 구성
언리얼 오브젝트에는 특별한 프로퍼티와 함수를 지정가능
메크로 안에 여러 메타데이터를 넣을수 있음
- UPROPERTY : 관리되는 클래스 멤버 변수
- UFUNCTION : 관리되는 클래스 멤버 함수

모든 언리얼 오브젝트는 클래스 정보를 담고있음
- 클래스를 사용해서 프로퍼티나 함수 정보를 컴파일과 런타임 때 조회 가능

NewObject_API 나 다른 걸로 생성을 해주어야 사용가능

## UObject시스템
1. 언리얼 오브젝트는 항상 클래스 정보를 담고 있는 UCLASS와 매칭 되어있음
2. UCLASS로 부터 언리얼 오브젝트의 정보를 파악가능
3. UCLASS에는 CDO가 연결되어 있음 , 개발의 생산성 향상

# UCLASS ( 언리얼 오브젝트 클래스 )
언리얼 엔진 시스템에서 사용되는 메타 클래스( meta-clas )
- meta-class란 클래스의 클래스로 클래스에 대한 메타정보를 가지고있음

어떤 클래스의 특성과 행동을 정의, 그 클래스의 인스턴스와 조작하는데 사용됨

UCLASS는 객체처럼 메모리에 할당되지 않고 클래스 형태로 존재

UCLASS는 클래스의 여러가지 정보를 기술하는 역할
- 이 정보는 인스턴스를 생성하고 동작을 정의하는데 사용

컴파일 단계에서 클래스의 정보를 표현하는데 사용

런타임 단계에서는 정보를 이용해서 객체를 생성하거나 조작함

UCLASS는 클래스의 템플릿임
- 템플릿이 되어서 다양한 형태의 클래스 인스턴스를 생성할 수 있는 구조
- UCLASS도 이와 유사하게 언리얼 엔진의 모든 클래스의 기반이 되며 클래스의 메타정보를 나타냄
- 메모리에 할당된 객체가 아니라 클래스 자체의 특성(클래스의 정보)을 나타내는 것으로 이해해야 함

UCLASS는 주로 리플렉션 시스템과 연관이 깊음

언리얼 엔진의 모든 클래스의 기반이 되며, 해당 클래스의 속성, 메서드, 상속구조, 블루프린트 등의 정보를 나타낸다.

UClass 를 통해 C++ 과 Blueprint 는 상호작용을 할 수 있게됨

Reflection System 이 있다고 하더라도, C++ 이 Blueprint 에 직접 접근하는 것이 아니라.
UClass 를 통해 간접적으로 접근할 수 있는 것

# Reflection ( 언리얼 프로퍼티 시스템 )
리플렉션은 프로그램이 실행시간에 자기 자신을 조사하는 기능

일반 C++ 오브젝트를 언리얼 오브젝트( UObject )로 만들기 위해 리플렉션을 활용

언리얼에서는 일반 c++ 객체 와 언리얼 오브젝트 객체 2가지로 나눌 수 있는데,
리플리케이션 시스템은 옵션

리플리케이션 시스템에 보이도록 했으면 하는 유형 

프로퍼티에 주석 을 달아주면, Unreal Header Tool (UHT) 가 그 프로젝트를 컴파일 할 때(컴파일전에) 해당 정보를 수집 h, cpp 파일을 generated.h cpp 파일로 저장

블루프린트 클래스는 게임 런타임에서만 실재로 존재
- 로직과 동작은 에디터가 실행되는 동안에만 실행됨
- 컴파일 타임(코드를 컴파일 하는 단계) 에서는 블루프린트 클래스의 구체적인 내용을 알 수 없음

리플렉션 시스템은 블루프린트 클래스와 같은 런타임 객체의 정보에 접근하고 조작할 수 있음
- 블루프린트 클래스의 존재을 알아내고, 그들의 속성과 메서드를 사용하려면, 리플렉션을 통해 런타임에서 해당 정보를 얻어와야 함
- C++ 은 블루프린트 클래스의 존재를 모름 리플렉션 시스템이 있어야, C++ 에서 블루프린트 클래스를 참조할 수 있음

# UHT ( 언리얼 헤더툴 )
UObject 클래스에게 제공되는 기능을 활용하기 위해서는 헤더파일에서 전처리 단계를 거쳐줘야 필요한 정보를 수집가능

빌드시 우선 UHT 는 소스코드를 분석하여 새로운 .generated.h 소스코드를 생성하고,

생성된 .generated.h 파일까지 컴파일 하여, 빌드가 완료가 됩니다.

UHT 은 실제 C++ 파서가 아닙니다.
해당 언어의 대부분을 이해하고 실제로 할 수 있는만큼 텍스트를 건너뛰긴 하지만,
리플렉션된 유형, 함수, 프로퍼티 에만 주의를 기우림

# UPROPERTY()
UPROPERTY는 언리얼 엔진에서 사용하는 메크로로 클래스의 멤버 변수를 언리얼 엔진의 리플렉션 시스템에 노출시키기 위해 사용됨, 다양한 메타데이터를 추가하여 언리얼 엔진이 해당 프로퍼티를 어떻게 처리할지 정의 , 변수의 가시성, 편집 가능 여부 직렬화 방법 등을 제어

가시성 및 편집 권한
- VisibleAnywhere: 에디터에서 볼 수 있지만 수정할 수는 없습니다.
- EditAnywhere: 에디터에서 볼 수 있으며 수정할 수 있습니다.
- VisibleDefaultsOnly: 기본값 탭에서만 볼 수 있으며 수정할 수 없습니다.
- EditDefaultsOnly: 기본값 탭에서만 볼 수 있으며 수정할 수 있습니다.
- VisibleInstanceOnly: 인스턴스에서만 볼 수 있으며 수정할 수 없습니다.
- EditInstanceOnly: 인스턴스에서만 볼 수 있으며 수정할 수 있습니다.

uproperty 메크로를 사용하면 

# CDO
CDO는 class Default Object의 약자로 CDO는 클래스의 기본 객체로 해당 클래스의 모든 인스턴스가 생성될 때 기본값을 제공하는데 사용

- 역할 및 개념
    - 클래스의 기본 속성 값을 저장, 인스턴스를 생성할 때 초기 값으로 사용됨
    - 클래스의 인스턴스가 생성될 때 마다 복사되어 초기화됨

- CDO 생성
    - 클래스가 처음 로드되거나 인스턴스화될 때 언리얼 엔지에서 자동으로 생성

- 접급법
    - GetDefault를 이용해서 접근이 가능

- CDO의 중요성
1. 성능 최적화
    - 클래스의 기본 상태를 유지하고 객체 초기화를 최적화하는 데 사용
2. 일관성 유지
    - CDO를 사용하면 일관된 초기 상태를 갖도록 보장할 수 있음
    - 유지보수와 디버깅에 용이
3. 데이터 관리
    - CDO 클래스의 기본 속성을 중앙에서 관리할 수 있도록 하여 인스턴스가 동일한 기본값을 공유할 수 있게됨

CDO 인스턴스가 값을 받는 것 생성자는 개별적으로 값을 하고 싶을 때

네트워크 측면에서도 여러 클라이언트가 같은 CDO를 사용함으로서 동기화에 장점이 있음

# Pawn
    폰은 게임 내에서 플레이어나 AI가 조작할 수 있는 캐릭터 또는 객체를 나타내는 중요한 클래스

> 기본적으로 게임 내에서 움직이고 상호작용할 수 있는 모든 것을 의미

> 플레이어를 기준으로 입력을 처리하는 느낌

## 폰의 주요 특징
1. 컨트롤 기능
    - 플레이어나 AI에 의해 제어될 수 있음
    - 플레이어 컨트롤러가 폼과 연결되어 움직임이나 행동을 조작

2. 이동과 상호작용
    - 게임 세계에서 이동할 수 있는 능력을 가지고 있으며 다른 객체와 상호작용할 수 있음

3. 카메라와 뷰포트
    - 폰은 보통 카메라를 포함하고 있어 플레이어에게 시점을 제공해줌

4. 다양한 활용
    - 플레이어 외에 AI가 움직이는 것에도 사용할 수 있음

점점 구체적인 개념 액터 -> 폰 -> 캐릭터으로 됨

# PlayerController
    언리얼 엔진에서 입력을 처리하고 게임 내 폰 또는 캐릭터에 전달하는 역할을 하는 중요한 클래스

> 간단하게 말해서 플레이어가 게임과 상호작용할 수 있게 해주는 중개자 역할

> 입력 매핑 플레이어 기준이 아닌 느낌으로, 여기서 입력 처리를 권장하지 않음

## 역할
1. 입력 처리
- 플레이어 컨트롤러는 입력을 인식하고 해당 입력을 폰또는 캐릭터에 전달

2. 폰과 상호작용
- 플레이어가 제어하는 폰이나 캐릭터에 연결됨

3. 카메라 및 HUD 제어
- 카메라 시점이나 HUD를 제어하는데 사용됨

4. 네트워킹
- 멀티플레이 게임에서 고유의 플레이어 컨트롤러를 가지고 독립적으로 게임에 참여해 상호작용할 수 있음

> 입력 -> 행동지시 -> 상호작용으로 작동함

# Gamemode vs Gamestate vs Playstate
    언리얼에서 Gamemode, Gamestate, Playstate는 게임의 상태와 흐름을 관리하는데 중요한 역할을 하는 핵심 클래스

    서로 협력하여 게임의 다양한 측면을 조율

## Gamemode
    게임의 전반적인 규칙과 흐름을 관리하는 클래스

Gamemode는 서버에만 존재함 클라이언트는 Gamemode의 정보를 직접적으로 접근하지 않음

- 주요역할
    - 게임 규칙 정의
        - 게임의 승리 조건, 점수 계산 방식, 스폰 규칙 등을 설정
    - 기본 클래스 정의
        - 게임에서 사용할 기본 클래스를 지정
            - 폰,플레이어 컨트롤러, HUD, playerState, GameState 등
    - 플레이어 스폰
        - 플레이어가 게임에 참가할 때 어떤 위치에 어떤 캐릭터로 스폰될지 결정

## GameState
    게임의 현재 상태를 추적하는 클래스

    서버와 모든 클라이언트 간에 동기화되는 정보를 담고 있음

주로 게임 내 전반적인 상태를 저장하고 클라이언트들에게 그 상태를 공유

- 주요 역할
    - 게임 진행 상황 추적
        - 끝났는지 진행중인지 등을 관리
    - 정보 관리 및 동기화

## PlayerState
    개별 플레이어의 상태를 추적하는 클래스

    각 플레이어에 대한 정보를 관리하고 클라이언트 간 동기화 됨

개인적인 게임 관련 정보가 포함됨

- 주요역할
    - 개인 정보 관리
        - 점수나 팀 정보 등
    - 동기화
    - 멀티플레이어 게임 지원

이 각각의 클래스들은 멀티플레이 상황에서 매우 중요함
- 동기화를 해야하기 때문에 매우 중요하게 사용됨

# Reflection
프로그램이 실행시간에 자기 자신을 조사하는 기능

Uclass에 저장됨

# Tick DeltaTime
## Tick
    게임이 플레이되는 동안 매 프레임마다 호출되는 함수

Tick함수는 매프레임 마다 호출되기 때문에 컴퓨터의 성능이 좋으면 좋을 수록 FPS가 높기 때문에 Tick함수가 빠르게 호출됨
- 컴퓨터의 성능에 따라 게임 환경이 달라짐 -> 게임 플레이가 달라짐
- 이를 컴퓨터의 성능에 상관없이 동일하게 할 필요가 있음
## Deltatime
    1프레임을 연산하는 데 소용되는 시간

어떤 값에 DeltaTime을 곱해줌으로써 프레임에 독립적으로 동작하게끔 구현할 수 있음

- 독립적이다?
    - DeltaTime을 곱해서 프레임 차이를 보정
    - 1 * DeltaTime을 하면 횟수많큼 값이 계산되기에 1초당 변경되는 값이 1로 동일함

프레임 환경이 달라짐에 따라 결과가 달라지지않게 되어서 프레임에 독립적이다 라고 말할 수 있음

# GC ( Garbage Collection )
사용하지 않는 객체를 자동으로 정리하여 메모리 누수를 방지하고 게임 성능을 유지하는데 도움을 줌

언리얼 엔진의 가비지 컬렉션은 C++기반으로 되어있음 UObject시스템과 깊게 통합되어있음

1. UObject와 가비지 컬렉션
- UObject
    - 언리얼 엔진의 모든 클래스와 객체의 기본 클래스
    - UObject를 상속받아서 만든 클래스는 엔지에서 다양하게 사용할 수 있음

- 자동 메모리 관리
    - UObject를 상속받는 클래스는 언리얼 엔진의 가비지 컬렉터에 의해 관리되며, 이로 인해 객체가 더 이상 사용되지 않을 때 자동으로 메모리가 해제됨

2. 가비지 컬렉션의 작동 원리
- 마크
    - 루트에서 시작해서 루트노드가 참조하고 있는 모든 UObject를 식별해서 마크함
    - 현재 마크된 객체로부터 다시 참조되고 있는 모든 UObject를 식별
    - 객체가 참조된 상태인지 아닌지를 검사하여 활성 객체를 표시
        - 모든 UObject는 서로 참조할 수 있으며, 참조된 객체는 "활성" 상태로 간주

    - 루트 객체 식별
        - 루트 객체란 가비지 컬렉션에서 절대로 제거되지 않는 객체
- 스윕 
    - 비활성 객체 제거
        - 마크 단계에서 참조되지 않은 객체를 제거하고 메모리를 회수

- 기타 주요 단어
    - 레퍼런스 카운트
        - 언리얼 엔진의 가비지 컬렉션 시스템은 객체의 레퍼런스를 추적 각 UObject는 참조 카운트를 가지며, 다른 객체에서 참조될 때 카운트가 증가하고 참조가 해제되면 카운트가 감소

    - 참조 그래프
        - 객체는참조 그래프를 통해서 서로 연결됨
        - 이 그래프를 탐색 참조되지 않는 객체를 찾음

    - 스케줄링
        - 가비지 컬렉션에서 일정한 주기로 자동으로 수행되며 필요에 따라 수동으로 호출 가능

3. 트리거
- 자동 트리거
    - 주기적으로 호출되어 실행됨
- 수동 트리거
    - 개발자의 필요에 따라 CollectGarbage() 함수를 호출하여 가비지 컬렉션을 수동으로 트리거

4. 추가 기능

GC 핸들링:
- 루트 추가 및 제거: 
    - UObject::AddToRoot()와 UObject::RemoveFromRoot() 메서드를 사용하여 객체를 루트에 추가하거나 제거할 수 있습니다. 루트에 추가된 객체는 GC의 대상에서 제외됩니다.

## 가지비 컬렉션을 위한 객체 저장소
관리되는 모든 언리얼 오브젝트의 정보를 저장하는 전역 변수 : GUObjectArray
- 언리얼 엔진이 활성화 된 순간에 누구나 GUObjectArray 에 접근할 수 있다.
- GUObjectArray 의 각 요소에는 플레그(Flag) 가 설정되어 있다.

가비지 컬렉터가 참고하는 주요 플래그
- Garbage 플래그 : 다른 언리얼 오브젝트로부터의 참조가 없어 회수 예정인 오브젝트
- RootSet 플래그 : 다른 언리얼 오브젝트로부터 참조가 없어도 회수하지 않는 특별한 오브젝트.

가비지 컬렉터는 GUObjectArray 에 있는 플래그를 확인해 빠르게 회수해야할 오브젝트를 파악하고 메모리에서 제거한다

# Actor Cycle
액터는 세 가지 경로로 인스턴스가 생성이 됨

크게 나눠서 보면

1. 액터를 로드,복사,스폰
2. 플레이용 액터 초기화
3. 컴포넌트 초기화 전 중 후
4. 플레이 시작
5. Destroy가 호출되거나 끝나면 Endplay에 의해서 마크되고 GC에 의해서 해제가 됨

## 디스크에서 로드
    이미 레벨에 있는 액터에 대해서 LoadMap 이 발생했을 때나 AddToWorld 가 호출되었을 때 발생
- 패키지/레벨에 있는 액터가 디스크에서 로드됨
- PostLoad 이후 - 디스크에서의 로드 완료후 serialize된 액터에 의해 호출된다 PostLoad와 PostActorCreated는 상호 배제 된다.
- InitializeActorsForPlay 플레이용 액터 초기화
- RouteActorInitialize 액터 초기화 경로 변경 - 초기화 되지 않은 액터에 대해 호출
    - PreInitializeComponents 컴포넌트 초기화 이전
    - InitializeComponent 컴포넌트 초기화
- PostInitializeComponents 컴포넌트 초기화 이후
- BeginPlay 플레이 시작

## 에디터에서 플레이
    액터를 디스크에서 로드하지않고 에디터에서 복사해옴
- 디터에 있는 액터를 새 월드로 복제한다.
- PostDuplicate 를 호출한다.
- InitializeActorsForPlay 플레이용 액터 초기화 호출
- 초기화되지 않은 액터는 RouteActorInitialize
    - PreInitializeComponents 컴포넌트 초기화 이전
    - InitializeComponent 컴포넌트 초기화
    - PostInitializeComponents 컴포넌트 초기화 이후
- BeginPlay 플레이 시작

## 스폰
    액터를 스폰할 때의 과정

- SpawnActor 호출
- PostSpawnInitialize 호출
- PostActorCreated 액터 생성 이후에 호출 PostActorCreated는 PostLoad와 상호배제적이다.
- ExecuteConstruction 생성 실행
    - OnConstruction 생성시 액터의 생성 지점으로, 블루프린트 액터가 컴포넌트를 만들고 변수를 초기화
- PostActorConstruction 액터 생성 이후
    - PreInitializeComponents 컴포넌트 초기화 이전
    - InitializeComponent 컴포넌트 초기화
    - PostInitializeComponents 컴포넌트 초기화 이후
- OnActorSpawned 액터 스폰시 UWorld에 브로드캐스팅 됨
- BeginPlay 플레이 시작
## 디퍼드 스폰
    Expose On Spawn (스폰시 노출)로 설정된 프로퍼티가 있으면 액터는 디퍼드(유예시키고 나중에 한번에 몰아서) 스폰이 가능하다.
    
## 수명의 마지막
액터 소멸은 여러가지 방식이 있지만 끝은 항상 같음

Destroy 소멸 - 수동으로 호출시 액터는 킬 대기 상태로 마킹되며 레벨의 액터 배열에서 제거

EndPlay 플레이 종료 - 액터의 수명이 끝났음을 보증하기 위해 호출된다. 플레이 도중에는 

Destroy나 LevelTransition이나 레벨이 언로드 되면 호출된다.
- Destroy 명시적 호출
- 에디터에서 플레이 종료
- Level Transition(심리스 트래블 또는 맵 로드)
- 액터가 들어있는 스트리밍 레벨 언로드
- 액터의 수명 만료
- 어플리케이션 종료 (모든 액터 소멸)

## 가비지 컬렉션
오브젝트가 소멸 마킹된 이후 가비지 컬렉션이 일어날 때 메모리에서 실제로 제거되어 리소스가 해제됨

# Cast<T>
UObject베이스 클래스들을 동적으로 안전하게 형변환해주는 함수

static_cast와 달리타입 안정성을 지님
  
Cast<T> 는 dynamic_cast 를 사용하지 않는다. dynamic_cast 대신 Cast<T> 를 사용해야함

내부적으로 TCastImpl에서 Docast라는 것을 호출

여기에서 C스타일의 캐스팅을 사용 -> const_cast를 먼저 시도하고 static_cast를 시동함
- 둘다 안되면 nullptr을 반환함
    - 안정성 증가
- FromCastFlags는 미리 설정된 비트 플래그를 기반으로 변환을 수행할 수 있는지 검증
    - 효율성 증가

또한 임의의 포인터 타입끼리 변환을 허용하는 reinterpret_cast는 허용하지 않음
- 리플렉션 시스템을 활용해서 CDO에 정보를 저장해 놓기 때문
- CDO 에 저장된 UStruct 객체 혹은 ClassCastFlags 를 검사하여 두 객체가 연관이 있는지 없는지를 파악한다

# UMG ( Unreal Motion Graphic )
    UMG = 언리얼 모션 그래픽스 = 슬레이트 + 예쁘고 커스터마이징 가능한 위젯을 위한 슬레이트 확장 + 비주얼 슬레이트 레이아웃 에디터 + 시퀀서.

언리얼 엔진의 비주얼 UI 제작 툴

미리 만들어진 Widget들을 조립해서 인게임 UI를 편리하게 만들 수 있다. 

- 시퀀서 
    - 모든 시스템(2D 및 3D)에 적용 가능한 타임라인 기반 편집 툴로, 현재 마티네 툴의 후속으로 설계되었습니다. UMG의 목표는 위젯 레이아웃과 애니메이션의 비주얼 편집을 지원하는 것이 목표

- 슬레이트 
    - 언리얼의 커스텀 UI 프로그래밍 프레임워크
    - Contents Browser 부터 시작하여 블루프린트 에디터, 애니메이션 에디터, 머테리얼 에디터 등등 엔진의 대부분을 차지하는 부분

# TList
언리얼 엔진에서 사용되는 링크드리스트이다
종류로는 
- TList
- TdoubleLinkedList
- TLinkedList

가 있다.

다만 언리얼엔진에서는 리스트에서 리플렉션을 지원하지 않아 많은 문제가 발생할 수 있음

때문에 언리얼에서는 연속된 자료구조 TArray, Tset이나 탐색속도가 빠른 TMap을 사용하는 것을 권장하고 있음

하지만 특정상황에서는 링크드 리스트를 사용하는게 더 좋을 수도 있음 빈번한 임의의 위치에 삽입삭제 같은 상황

stl list와 unreal의 tlist는 큰 차이점은 없음 리플렉션을 지원하지 않아서 별 다른 점은 없지만 다른 자료구조와 API에 통합성이 좋음

템플릿 기반으로 구현되어 타입 안전성을 제공함
