# FSM
특정 시스템이 시간의 흐름에 따라 여러 상태를 가질 수 있으며 입력에 따라 상태가 변화하는 방식

## 구성요소
1. 상태
    - 시스템이 특정 시점에서 있을 수 있는 상태를 나타냄

2. 입력
    - 시스템이 외부에서 받은 자극이나 이벤트를 의미

3. 전이 
    - 입력에 따라 시스템이 한 상태에서 다른 상태로 변화하는 것을 의미

4. 행동
    - 상태 전이와 함께 발생하는 동작을 의미
    - 상태가 변화할 때마다 실행됨, 출력 결과를 생성

## 유형
FSM은 크게 두가지 유형으로 나눌 수 있음
- 단순형 FSM 
    - 상태 뿐만아니라 입력에 의해서도 출력이 결정되는 형태
    - 주로 AI나 입력을 통해서 상태를 변경할 때
- 무어형 FSM
    - 출력이 현재 상태에 의해서만 결정되는 형태
    - 입력이 변해도 현재 상태가 변하지 않음
    - 게임에서 상태가 스스로 변화하지 못하는 오브젝트
        - 문, 게임의 상태

# Behavior Tree
게임 AI.로봇 제어 등 복잡한 행동을 설계하는 다양한 응용 분야에서 사용되는 모델링 도구

계층적인 구조를 가지고 있으며 노드들의 집합으로 구성되어있음

즉정 조건에 따라 트리의 다른 부분을 실행하거나 결정된 행동을 수행하게 됨

## 구성요소
1. 루트 노드
    - 트리의 시작점으로 트리의 맨 위에 위치한 노드
    - 모든 행동은 루트에서 시작해서 하위 노드로 전파됨

2. 내부 노드
    크게 두가지 유형으로 나뉨
    - Composite 노드
        - 아래에 여러 노드를 가질 수 있고 순차적으로 실행
        - Sequence 노드
            - 자식 노드들을 순차 적으로 실행
            - 자식 노드가 모두 성공하면 Sequence노드도 성공, 하나라도 실패하면 실패를 반환
        - Selector 노드
            - 자식 노드들을 순차적으로 실행
            - 하나라도 성공하면 성공 , 하나라도 실패하면 실패를 반환
        - Parallel 노드
            - 여러 자식 노드를 동시에 실행 특정 조건에 맞을 때 까지 실행을 유지 혹은 중지 할 수 있음
    - Decorator 노드
        - 아래세 하나의 노드를 가질 수 있음
        - 자식 노드의 결과를 변경하거나 특정 조건에 따라 자식 도드의 실행을 제어
        - Inverter
            - 자식 노드의 결과를 반대로 변경
        - Repeater
            - 자식 노드를 지정 횟수 또는 특정 조건에 충족할 때 까지 반복
        - Succrrder
            - 자식 노드가 실패하더라도 항상 성공을 반환

3. Leaf노드
    트리의 맨 마지막 노드들로 실제 행동을 수행하거나 조건을 평가
    - Action 노드 
        - 특정 행동을 정의하고 실행함
    - Condiotion 노드
        - 특정 조건을 평가하여 그결과에 따라 행동을 결정

## BlackBoard
    트리의 여러 노드 간의 정보 공유하는 역할을 하는 저장소
- 공유 메모리로서의 역할
    - 트리의 여러 부분에서 데이터를 읽고 쓰는게 가능하고 노드간의 협력이 필요할 때 사용

# FSM vs Behavior Tree
1. 구조 및 설계 접근 방식
- FSM은 상태와 상태간의 전이로 구성된 모델

    항상 특정 상태에 있으며 외부 입력이나 이벤트에 따라 다른 상태로 전이
    - 상태와 전이의 명확한 정의로 구성된 선형적 구조
    - 전이 조선을 명시적으로 정의 해야함
    - 상태가 많아지면 설계가 복잡해짐

- Behavior Tree

    트리 구조로, 루트 노드에서 시작하여 자식노드를 순차적으로 탐색하고 실행함
    - 계층적이고 모듈화된 트리 구조, 다양한 행동을 노드 단위로 구성
    - 행동을 노드 단위로 분리하고 조합해 복잡한 행동을 직관적으로 설계 가능

2. 복잡성 및 확장성
- FSM은 설계가 단순할 때 직관적이고 이해하기 쉽지만 상태와 전이가 증가할수록 복잡성이 증가
    - 유지보수가 어려워 질수 있음
    - 행동을 추가 할 때 마다 새로운 상태를 정의해야해서 확장성이 제한 적임

- Behavoir tree는 복잡한 행동을 계층적 구조로 분할할 수 있어 확장성과 모듈성이 뛰어남 행동을 추가하거나 기존 행동을 수정할 대 트리 구조를 재사용할 수 있음
    - 때문에 유연성이 FSM보다 좋음

3. 제어 흐름 및 행동 결정
FSM과 Behavior Tree의 가장 큰 차이점으로 FSM은 상태에 따라 어떤 행동을 할지 결정됨

Behavoir Tree는 트리 구조에 따라 탐색하여 제어 흐름 노드에 따락가서 Action노드에서 행동을 함