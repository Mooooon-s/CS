# DirectX
    왼손 좌표계를 이용하는 그래픽 api

    객체 접근방식의 문법

    HLSL을 사용

- OpenGL과의 차이점
    - 오른손 좌표계
    - c스타일의 함수 호출방식의 문법
    - GLSL을 사용

## Device, Device Context
DirectX11을 사용할 때 반드시 이해해야하는 주된 인터페이스

### Device
GPU의 메모리같은 것

하드웨어와 상호작용하여 GPU에 리소스를 할당하거나 백 버퍼를 지우게 하는 등의 일을 시킬 수 있게 하는 인터페이스

자원들을 생성할때사용되는 인터페이스

셰이더 프로그램 객체, 자원, 상태 객체, 질의 객체 등의 생성을 위한 메서드들을 제공

여러 하드웨어 기능들의 사용 가능 여부를 점검하는 메서드들과 진단 및 디버그 메서드도 제공

### Device Context
디바이스가 가진 리소스를 이용해 파이프라인 상태를 설정하고( 바인딩 ) 렌더링 명령을 생성하는 데 사용되는 인터페이스

장치문맥이라고도 함

장치로 생성한 자원이나 상태 객체를 파이프라인에 묶는데 사용

쉽게 말해서 파이프라인 자체를 조작할때 사용

렌더링 파이프라인과 컴퓨트 파이프라인의 실행을 제어하는 수단을 제공

장치로 생성한 자원을 조작하는 수단도 제공

추가로 즉시 문맥 과 지연 문맥이 있음
- Immediate Context는 파이프라인에 직접 연결되는 통로로 바로 전달해서 명령이 구동기에서 실행됨

- Defferred Context는 2차적으로 다른 쓰레드들이 보낸 일련을 명령을 저장하는 역할을 함 저장해 놓고 주 스레드에서 이 명령들을 수행 할 것임

- Depthstencil 이나 버퍼같이 다른 것들을 묶어서 넘길수 있음

- 셰이더,셰이더 파라미터등이 바인드됨

## Swap Chain
티어링 현상을 어느정도 완화하기 위해 만들어진 기법

렌더링된 이미지를 화면에 표시하는 과정을 관리하는 시스템

렌더링하기 위해서는 그리고 지우고 그리고 지우고를 반복하게 되는데 담을 수 있는 버퍼가 하나라면 깜박이는 현상이 발생하게 된다.

이를 해결하기위해서 프론트 버퍼와 백 버퍼를 두어 두개를 번가라가면서 화면에 띄우면 이런 현상을 해결할 수 있다.

## Double buffering

- 프론트 버퍼
    - 현재 화면에 표시되고있는 버퍼
- 백 버퍼
    - 다음에 화면에 표시될 이미지를 렌더링하는 버퍼

일반적으로 더블 버퍼링을 통해서 렌더링을 하게되는데 이를 관리하기 위해서 스왑체인이라는 시스템을 사용

- 스왑체인
    - 프로트 버퍼와 벡 버퍼를 전환을 관리하는 시스템
    - 렌더링 -> 버퍼스왑 -> 화면에 표시

### 장점
1. 화면 깜박임 감소 : 지웠다 그리는 모습이 잘 담기지 않기 때문에 감소
2. 프레임 향상 :  미리 그려져있기 때문
3. 동기화: 프레임과 렌더링 시간을 동기화해서 일관된 화면 출력 제공

## Triple buffering
더블 버퍼에서 버퍼 하나를 더 추가한 버퍼링기법

티어링 형상을 더블 버퍼보다 더 줄이기 위해서 생성된 방법 ( 완벽하게 줄여주지 못함 )

버퍼를 3개 두고 그리는 버퍼 두개와 화면에 출력하는 버퍼하나를 두어서 더블 버퍼링과 다른게 렌더링과 출력하는 버퍼를 구분

더블 버퍼링에서는 렌더링이 완료되면 교환하게 됨 이렇게 되면 렌더링이 되기전에 아주 찰라의 시간이 밀리게 되는데

삼중 버퍼를 이용하면 이를 어느정도 해결할 수 있음

먼저 완성된 것을 복사해서 그리고 나머지는 계속해서 그릴수 있기 때문에 좀더 짧게 그리수 있음

### 수직 동기화
보통 트리플 버퍼링과 함께 사용됨
    gpu가 렌더링된 이미지를 모니터의 주사율과 맞춰서 보내줌

완성된 이미지만 오기 때문에 티어링 현상을 대부분의 상황에서 제거 할 수 있음

#### 단점
- 인풋렉이 발생 할 수 있음

- gpu의 성능이 안 좋으면 반대로 절반의 성능이 발생 할 수 있음
    - 화면을 새로 출력해야 하는데 렌더링이 되어있지 않으면 이전 프레임을 다시 출력

- 극한의 상황에서는 일어날 수 있음
    - 너무 낮은 프레임 속도일 때 동기화 하려다 중단된 화면이 출력 될 수 있음

### 그 외 티어링 해결 방법
G-sync,free-sync를 이용할 수 있음

gpu의 렌더링 속도에 맞춰서 모니터의 주사율을 동적으로 함

45프레임으로 렌더링이 된다면 모니터의 주사율을 45프레임으로 출력

## Index 버퍼
정점 버퍼의 정점들을 참조하여 정점이 그려질 순서를 저장하는 버퍼로 실제 렌더링시 정점 버퍼에 존재하는 정점 데이터를 재사용 할 수 있음

렌더링시 겹치는 부분의 데이터를 인덱스 버퍼를 이용해서 그리게 되면 중복되는 데이터를 줄일 수 있음

- 정점 버퍼만 이용하면 그려야할 순서대로 중복된 정점을 추가 하게 되는데

- 인덱스 버퍼를 이용하면 중복된 정점을 추가할 필요가 없어짐
- Vector3 의 24바이트를 쓸거 int 4바이트만 쓰면됨

메모리 절야 , 성능 향상의 장점이 있음

## Drawcall
렌더링할 때 한번 그릴 때 라는 것을 말하는 것

cpu가 gpu에게 어떤걸 그려라 하는 명령어

 - 인스턴싱
    - 같은 메쉬를 사용하는 것들을 한번에 묶어서 그려서 한번의 드로우 콜에 동시에 그림
- 배칭
    - 여러 오브젝트를 하나의 버텍스 버퍼로 담아서 그리는거
    - 인덱스버퍼나 버텍스 버퍼를 하나로 보내버리는 거

## Culling
실시간 렌더링 방식에서 레더링 할 필요가 없는 요소들을 선별해 렌더링을 하지 않아서 부하를 줄이는 방법

1. 후면 컬링 ( backface culling )
물체의 뒷부분을 렌더링에서 배체하는 기법

2. 시각 절두체 선별  ( frustrum culling )
카메라의 시야 범위 외의 객체들을 선별해 이들을 렌더링에서 제외 시킴

3. 차페 선별 ( Occlusion Culling )
앞에 있는 물체에 의해 완전히 가려진 뒤쪽의 물체를 렌더링에서 배제하는 방식