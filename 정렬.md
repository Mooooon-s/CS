# 정렬 알고리즘
## Quick Sort
    비교 기반의 정렬 알고리즘
분할 정복을 사용하여 정렬을 수행
### 기본 알고리즘
1. 피벗 선택
    - 배열에서 하나의 요소를 선택하여 피벗으로 설정
    - 피벗은 배열을 나누는 기준이 되는 요소
2. 분할
    - 피벗을 기준으로 배열을 두개의 서브 배열로 분할
    - 피벗보다 작은 값은 왼쪽 큰 값은 오른쪽으로 이동
3. 재귀 호출
    - 분할된 두개의 서브 배열에 대해서 다시한번 퀵소트 알고리즘을 사용
    - 서브 배열의 크기가 1이하일 때(정렬이 완료된 상태)까지 반복

![alt text](quick-sort.png)

### 시간 복잡도
평균 O(nlogn)

최악 O(n^2)
- 피벗 선택이 불균형하게 이루어질 경우

## Bubble Sort
    배열의 인접한 요소들을 비교하고 교환하여 정렬

    큰 요소가 위로 올라가는게 물방울이 올라가는 것 처럼 보인다고 해서 버블 소트라고 한다

### 기본 알고리즘
인접한 요소들을 비교하고 교환하여 정렬을 수행 배열의 끝까지 반복됨
1. 비교 및 교환
    - 배열의 첫 번째 요소부터 시작하여 인접한 두 요소를 비교
    - 첫 번째 요소가 크면 교환
    - 배열의 끝까지 이 작업을 반복

2. 다시 반복
    - 각 반복에서는 마지막 부분을 제외하고 비교 및 교환을 수행합니다.
    - 비교하는 범위가 줄어든다는 말임

![alt text](bubble-sort.png)

### 시간 복잡도
평균적으로 O(n^2)정도 걸림 최악의 경우도 같음

## Merge Sort
    교 기반의 정렬 알고리즘 중 하나로, 분할 정복(Divide and Conquer) 전략을 사용하여 배열을 정렬

병합 정렬은 안정적인 정렬 알고리즘

### 병합 정렬의 기본 원리
병합 정렬은 배열을 재귀적으로 나누고 정렬하여 다시 병합하는 방식으로 작동

크게 분할과 정렬및 병합으로 나눌 수 있음

동일한 키를 가진 요소의 상대적인 순서가 정렬 후에도 유지

이 특성 덕분에 병합 정렬은 안정성 요구 사항이 있는 정렬 문제에 적합

### 기본 알고리즘
1. 분할 단계
배열을 반으로 나누기
- 배열의 중간 지점을 찾음
- 배열을 두개의 하위 배열로 나누고 각 하위 배열에 병합 정렬을 호출
- 크기가 1이 될 때 까지 반복

2. 병합 단계
- 두 개의 정렬된 배열 병합
    - 두 개의 정렬된 하위 배열을 병합 하여 하나의 정렬된 배열을 만듬
    - 첫 번째 요소부터 시작하여 비교하고 더 작은 값을 결과 배열에 추가
    - 한 배열의 요소를 모두 처리한후 나머지 요소들을 결과 배열에 추가

- 병합 과정
    - 각 하위 배열의 요소를 순차적으로 비교하고 더작은 요소를 선택하여 결과 배열에 추가
    - 모든 요소가 병합되면 정렬된 배열이 됨

    이동 횟수는 2nlongn 만큼이동함

![alt text](merge-sort-concepts.png)

### 시간 복잡도
병합 정렬의 시간 복잡도는 배열의 크기가 n일 때 항상 O(n log n)

 이는 배열을 분할하는 과정과 병합하는 과정 각각이 log n의 깊이를 가지기 때문