# Emplace
C++의 STL에서 제공해주는 함수로 컨테이너에서 키값으로 된 요소가 없을 때 새로운 요소를 삽입 시켜주는 함수

emplace를 사용하면 불필요한 복사 또는 이동작업을 피하면서 요수를 추가할 수 있음

    vector나 queue에 넣을 때 여러 인자로 pair나 tuple을 만들 필요없이 바로 넣을수 있게 해주기 때문에 불필요한 복사난 이동이 없음

반복자 및 참조자가 무효화 되지않음

- push(): 대입 복사
- emplace() : 생성해서 넣음 때문에 생성에 필요한 이자만 주면됨

- 

# Vector
배열처럼 순차적으로 데이터를 저장하는 시퀀스 컨테이너로 쉽게 말해서 가변 배열이라고 할 수 있음

순차적으로 데이터가 저장되어있기 때문에 접근하는 것이 매우 빠름
- 임의의 위치를 탐색할 때 O(1)
- 임의의 위치에 데이터를 삽입 삭제 O(n)

벡터는 일반적으로 원소의 개수보다 더 많은 공간이 할당되어 있음

할당 되어있는 공간을 모두 사용했을 경우 새로운 공간에 더 큰 공간을 할당해서 데이터들을 복사해서 옮김

반복자를 이용해서 접근이 가능함
- 컨테이너 원소에 접근할수 있는 포인터와 같은 객체

하지만 데이터를 삽입 삭제하면 반복자가 무효화되어 사용할 수 없음 반복자를 다시 갱신해서 사용해야 함

캐시친화성이 있음 페이징폴트가 적게 일어나기 때문에 vector가 더 좋음

# List
양반향 연결구조를 가진 자료형

Vector와 달리 임의의 위치에 바로 접근할 수 없음 시작위치와 마지막위치만 기억하고 있기 때문에 임의의 위치에 접근하고 싶다면 연결된 부분을 타고 들어가야함

리스트는 벡터와 다르게 임의의 위치에 데이터를 삽입하는 것이 매우 빠름 연결 부분만 갈아 치우면 되기 때문

리스트는 벡터와 다르게 삽입 삭제 작업을 해도 반복자가 무효화되지 않음

# set
연관 컨테이너중 하나

특징
- 노드 기반 컨테이너로 균형 이진트리로 구현되어있다.
- key라 불리는 원소들의 집합으로 이루어진 컨테이너
- key는 중복이 허용되지 않음
- 원소는 삽입되는 순서 상관없이 ***삽입되면 자동으로 정렬됨***
    - 기본적으로 오름차순
- 중위순회를 통해 순서대로 출력가능

- insert, erase를 이용

# map
각 노드가 key와 value 쌍으로 이루어진 트리 *** key값은 중복을 허용하지 않음 value는 중복을 허용 ***

특징
- pair객체로 저장됨
    - first가 키 , second가 값
- 시간복잡도가 (logN)을 보장함
    - 레드블랙트리로 구성되어있기 때문
- 자료를 저장할때 자동으로 정렬
    - 기본적으로 오름차순

# unordered_map
각 노드가 key와 value쌍으로 이루어진 자료구조 map과 똑같이 *** key값은 중복을 허용하지 않음***

unordered_map은 해쉬 테이블로 구현한 자료구조로 탐색 시간 복잡도는 O(1)임

map 보다 더빠른 탐색을 하기 위한 자료구조임

map에 비해 데이터가 많으면 많을수록 성능이 월등히 좋아짐

Hash 테이블로 구현이 되어있기 때문에 Hash충돌을 신경써주어야함

## hash Collision
unordered_map은 hash자료구조를 이용하기 때문에 해시충돌의 가능성이 있다 해시 충돌이 일어나면 성능저하가 발생함

체이닝을 통해서 동일한 버킷에 여러 데이터가 들어가게 되는데

 버킷안에서 연결리스트 또는 벡터를 순회해야하기 때문에 조회 삽입 삭제 등의 연산이 느려짐

 평균적으로 O(1) 시간에 수행 되지만 해시충돌이 일어나면 O(n)까지 떨어질 수 있음

- 일어나는 이유
    - 키 값을 제대로 분산하지 못할 경우
    - 높은 로드 팩터 때문에
        - 저장된 항목 수를 버킷 수로 나눈 값으로 버킷에 저장되는 항목 수도 많아짐

    - 리해싱 오버해드
        - 테이블의 크기를 늘리고 모드 항목을 새로운 해시 값에 따라 재배치하는 과정
        - 새롭게 해시하고 재배치하기 떄문에 많은 오버해드가 발생할 수 있음

    - 비 효율적인 메모리 관리
        - 해시 테이블이 매우 커지면 메모리에서 데이터 접근이 분산되고 캐시 성능이 낮아짐

- 해결법?
    - 커스텀 해시 함수 또는 좋은 해시 함수 선택
    - 적절한 리해싱 및 로드 팩터 유지

# map vs unordered_map
가장 큰 차이는 자동 정렬에 있음
map은 자동정렬이 되지만 unordered_map은 정렬이 안됨

# List vs Set vs Map
## List
    순서 유지, 중복허용
## set
    순서 상관없음 자동 정렬 , 중복 허용되지 않음
## map
    순서 상관없음 key값으로 자동 정렬, key값은 중복 허용되지않음 , value는 중복 허용

map은 set에 비해 더 많은 메모리와 연산이 들지만 단일요소가 아닌 연관된 값을 빠르게 찾을수 있으므로 적절히 사용하는게 좋다.

